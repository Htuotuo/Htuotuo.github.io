<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webservice的Restful风格]]></title>
    <url>%2F2018%2F02%2F24%2Fwebservice%E7%9A%84Restful%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[作用web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的xml（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。用于多系统之间的交互 什么是Web ServiceWeb service 就是一个应用程序，它向外界暴露出一个能够通过Web进行调用的API Web services是建立可互操作的分布式应用程序的新平台 Web service平台是一套标准，它定义了应用程序如何在Web上实现互操作性。你可以用任何你喜欢的语言，在任何你喜欢的平台上写Web service ，只要我们可以通过Web service标准对这些服务进行查询和访问。 JAX-WS 独立服务使用(了解)JAX-RS 独立服务使用(了解)restful风格好处： 基于这种风格架构，软件编写可以更简洁 基于 HTTP 协议， 支持多种消息格式，比如 XML 、 JSON 更易于实现缓存机制（第一次访问资源 缓存，第二次访问资源，返回 304 客户端调用本地） 以上定义的只是一种风格不是一种固定格式 POST 请求方式访问 保存操作 PUT 请求方式访问 修改操作 GET 请求方式访问 查询操作 DELETE 请求方式访问 删除操作 JAX-RS的使用步骤：1.基于 maven 导入坐标2、 导入实体类 在实体类上一定要加入@XmlRootElement(name=&quot;User&quot;); @XmlRootElement 指定序列化（转换 XML、 JSON） 对象名字 如果没加@XmlRootElement(name=&quot;User&quot;)注解就会出现以下错误： 如果该类使用了泛型还需添加另一个注解@XmlSeeAlso({ xxx.class })中括号中添加为泛型的类型的类 3、 编写业务类 第一种 @Path 服务访问资源路径 如果访问 saveUser 方法 /userService/user 第二种 @Produces 生成（方法返回值） @Consumes 消费 （方法参数） @Consumes 指定能够处理客户端传递过来数据格式 @Produces 指定能否生成哪种格式数据返回给客户端 第三种 @GET 查询 @PUT 修改 @POST 增加 @DELETE 删除 4、 发布服务（单独发布） 5、 客户端程序的编写有两种做法 1） 使用 http client 工具 ，需要自己对 HTTP 协议内容进行定制和解析 2） WebClient 工具类使用 （CXF 自带） JAX-RS 如何传输 JSON 格式的数据 ？ 如果指定客户端要获取 json 内容 错误： Caused by: javax.ws.rs.ProcessingException: No message body writer has been found for class cn.itcast.cxf.domain.User, ContentType: application/json 解决： 在项目引入 json 转换器 JAX-RS 和 Spring 整合开发使用（重点）1.maven坐标引入 导入 web.xml，在web.xml中需要添加一个webservice配置 2、 导入实体类和 Service3、 在 spring 配置发布 rs 服务引入名称空间 xmlns:jaxrs=&quot;http://cxf.apache.org/jaxrs&quot; http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/jaxrs.xsd 最终访问资源服务路径 服务器根目录地址 + web.xml 配置 + applicationContext.xml address 配置 + 类@Path +方法 @Path applicationContext-webservice.xml服务端配置 4、 编写客户端代码 类似独立服务客户端代码WebClient 工具实现，客户端不需要进行配置 直接使用webclient。create方法进行调用，访问路径参照： 服务器根目录地址 + web.xml 配置 + applicationContext.xml address 配置 + 类@Path +方法 @Path // 使用webClient调用 webService接口 Collection&lt;? extends Customer&gt; collection = WebClient .create(&quot;http://localhost:9002/crm_management/services/userservice/xxx&quot;) .accept(MediaType.APPLICATION_JSON) .getCollection(Customer.class); 如果有返回值，返回的是结果集就使用getConllection获取，单个结果就直接使用get accept为接收返回值 注意：在webservice中服务方法参数有两个注解： @pathParam 如果在方法参数中使用该配置，在客户端访问路径/后面直接拼接参数 @queryparam 如果在方法参数中使用该配置，在客户端访问路径必须使用？&amp;的方式进行参数的拼接 在用于分布式系统间的通讯，还有一个dubbo（个人觉得dubbo更好使用）1.什么是dubbo随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。 垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web框架(MVC) 是关键。 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。 流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。Dubbo就是资源调度和治理中心的管理工具。 2.Dubbo的架构 节点角色说明： Provider: 暴露服务的服务提供方。 Consumer: 调用远程服务的服务消费方。 Registry: 服务注册与发现的注册中心。 Monitor: 统计服务的调用次调和调用时间的监控中心。 Container: 服务运行容器。 调用关系说明： 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 3.使用方法1.Spring配置 Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。 单一工程中spring的配置 &lt;bean id=&quot;xxxService&quot; class=&quot;com.xxx.XxxServiceImpl&quot; /&gt; &lt;bean id=&quot;xxxAction&quot; class=&quot;com.xxx.XxxAction&quot;&gt; &lt;property name=&quot;xxxService&quot; ref=&quot;xxxService&quot; /&gt; &lt;/bean&gt; 远程服务： 在本地服务的基础上，只需做简单配置，即可完成远程化： 将上面的local.xml配置拆分成两份，将服务定义部分放在服务提供方remote-provider.xml，将服务引用部分放在服务消费方remote-consumer.xml。 并在提供方增加暴露服务配置&lt;dubbo:service&gt;，在消费方增加引用服务配置&lt;dubbo:reference&gt;。 发布服务： &lt;!-- 和本地服务一样实现远程服务 --&gt; &lt;bean id=&quot;xxxService&quot; class=&quot;com.xxx.XxxServiceImpl&quot; /&gt; &lt;!-- 增加暴露远程服务配置 --&gt; &lt;dubbo:service interface=&quot;com.xxx.XxxService&quot; ref=&quot;xxxService&quot; /&gt; 调用服务： &lt;!-- 增加引用远程服务配置 --&gt; &lt;dubbo:reference id=&quot;xxxService&quot; interface=&quot;com.xxx.XxxService&quot; /&gt; &lt;!-- 和本地服务一样使用远程服务 --&gt; &lt;bean id=&quot;xxxAction&quot; class=&quot;com.xxx.XxxAction&quot;&gt; &lt;property name=&quot;xxxService&quot; ref=&quot;xxxService&quot; /&gt; &lt;/bean&gt; 2.注册中心 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。使用dubbo-2.3.3以上版本，建议使用zookeeper注册中心。 Zookeeper是Apacahe Hadoop的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 Zookeeper的安装： 第一步：安装jdk 第二步：解压缩zookeeper压缩包 第三步：将conf文件夹下zoo_sample.cfg复制一份，改名为zoo.cfg 第四步：修改配置dataDir属性，指定一个真实目录 第五步： 启动zookeeper：bin/zkServer.sh start 关闭zookeeper：bin/zkServer.sh stop 查看zookeeper状态：bin/zkServer.sh status 4.框架整合添加dubbo的依赖加入dubbo相关的jar包。服务层、表现层都添加。 &lt;!-- dubbo相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;!-- 排除依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.jboss.netty&lt;/groupId&gt; &lt;artifactId&gt;netty&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;/dependency&gt; 整合思路1、Dao层： mybatis整合spring，通过spring管理SqlSessionFactory、mapper代理对象。需要mybatis和spring的整合包。 整合内容 对应工程 Pojo 项目名称 Mapper映射文件 项目名称 Mapper接口 项目名称 sqlmapConfig.xml 项目名称 applicationContext-dao.xml 项目名称 2、Service层： 所有的service实现类都放到spring容器中管理。由spring创建数据库连接池，并有spring管理实务。发布dubbo服务 整合内容 对应工程 Service接口 项目名称 service实现类 项目名称 applicationContext-service.xml 项目名称 applicationContext-trans.xml 项目名称（事务配置文件） 3、表现层： Springmvc框架，由springmvc管理controller。引用dubbo服务 整合内容 对应工程 Springmvc.xml（扫描controller、引用dubbo服务） 项目名称 Controller 项目名称 Dao整合创建SqlMapConfig.xml配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;/configuration&gt; 4.3.2.Spring整合mybatis 创建applicationContext-dao.xml &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd&quot;&gt; &lt;!-- 数据库连接池 --&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:properties/*.properties&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt; &lt;property name=&quot;minIdle&quot; value=&quot;5&quot; /&gt; &lt;/bean&gt; &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 加载mybatis的全局配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt; &lt;/bean&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.taotao.mapper&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; db.properties jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/taotao?characterEncoding=utf-8 jdbc.username=root jdbc.password=root 备注： Druid是目前最好的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss DataSource。 Druid已经在阿里巴巴部署了超过600个应用，经过多年多生产环境大规模部署的严苛考验。 Service整合管理Service &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.taotao.service&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 使用dubbo发布服务 --&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name=&quot;taotao-manager&quot; /&gt; &lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183&quot; /&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface=&quot;com.taotao.service.ItemService&quot; ref=&quot;itemServiceImpl&quot; /&gt; &lt;/beans&gt; 事务管理创建applicationContext-trans.xml &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd&quot;&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;create*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;select*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切面 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* com.taotao.service.*.*(..))&quot; /&gt; &lt;/aop:config&gt; &lt;/beans&gt; Web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;taotao-manager&lt;/display-name&gt; &lt;!-- 加载spring容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;/web-app&gt; 表现层整合Springmvc.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.taotao.controller&quot; /&gt; &lt;mvc:annotation-driven /&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!-- 引用dubbo服务 --&gt; &lt;dubbo:application name=&quot;taotao-manager-web&quot;/&gt; &lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183&quot;/&gt; &lt;dubbo:reference interface=&quot;com.taotao.service.ItemService&quot; id=&quot;itemService&quot; /&gt; &lt;/beans&gt; web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;taotao-manager-web&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 解决post乱码 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- springmvc的前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;taotao-manager&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+&quot;-servlet.xml&quot; --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;taotao-manager&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[redis命令]]></title>
    <url>%2F2018%2F02%2F24%2Fredis%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.Redis hash 常用命令1、HDEL key field1 [field2] 删除一个或多个哈希表字段` 2、HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。 3、HGET key field 获取存储在哈希表中指定字段的值。` 4、HGETALL key 获取在哈希表中指定 key 的所有字段和值 5、HKEYS key 获取所有哈希表中的字段 6、HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment 。 7、HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 8、HLEN key 获取哈希表中字段的数量 9、HMGET key field1 [field2] 获取所有给定字段的值 10、HMSET key field1 value1 [field2 value2 ] 同时将多个 field-value (域-值)对设置到哈希表 key 中。 11、HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。 12、HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。 2.Redis String 常用命令1、SET key value 设置指定 key 的值 2、GET key 获取指定 key 的值。 3、GETRANGE key start end 返回 key 中字符串值的子字符 4、GETSET key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 5、GETBIT key offset 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 6、MGET key1 [key2..] 获取所有(一个或多个)给定 key 的值。 7、SETBIT key offset value 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。 8、SETEX key seconds value 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。 9、SETNX key value 只有在 key 不存在时设置 key 的值。 10、SETRANGE key offset value 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。 11、STRLEN key 返回 key 所储存的字符串值的长度。 12、MSET key value [key value ...] 同时设置一个或多个 key-value 对。 13、MSETNX key value [key value ...] 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 14、PSETEX key milliseconds value 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。 15、INCR key 将 key 中储存的数字值增一。 16、INCRBY key increment 将 key 所储存的值加上给定的增量值（increment） 。 17、INCRBYFLOAT key increment 将 key 所储存的值加上给定的浮点增量值（increment） 。 18、DECR key 将 key 中储存的数字值减一。 19、DECRBY key decrement key 所储存的值减去给定的减量值（decrement） 。 20、APPEND key value 如果 key 已经存在并且是一个字符串， APPEND 命令将 指定value 追加到改 key 原来的值（value）的末尾。]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux常见命令]]></title>
    <url>%2F2018%2F02%2F24%2Flinux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[手动配置IP地址自动获取IP地址虚拟机使用桥接模式，相当于连接到物理机的网络里，物理机网络有DHCP服务器自动分配IP地址。 #dhclient 自动获取ip地址命令 #ifconfig 查询系统里网卡信息，ip地址、MAC地址 分配到ip地址后，用物理机进行ping ip地址，检测是否ping通。 手动设置ip地址如果虚拟机不能自动获取IP，只能手动配置，配置方法如下： 输入命令 #vi /etc/sysconfig/network-scripts/ifcfg-eth0 编辑网卡的配置文件 输入上述命令后回车，打开配置文件，使用方向键移动光标到最后一行，按字母键“O”，进入编辑模式，输入以下内容： IPADDR=192.168.25.10 NETMASK=255.255.255.0 GATEWAY=192.168.25.1 另外光标移动到”ONBOOT=no”这一行，更改为ONBOOT=yes “BOOTPROTO=dhcp”，更改为BOOTPROTO=none 完成后，按一下键盘左上角ESC键，输入:wq 在屏幕的左下方可以看到，输入回车保存配置文件。 之后需要重启一下网络服务，命令为 #service network restart 网络重启后，eth0的ip就生效了，使用命令#ifconfigeth0 查看 接下来检测配置的IP是否可以ping通，在物理机使用快捷键WINDOWS+R 打开运行框，输入命令cmd，输入ping 192.168.4.10 进行检测，ping通说明IP配置正确。 备注：我所在的物理机网段为192.168.4.0 网段。大家做实验的时候根据自己的环境进行设定，保持虚拟机和物理机在同一网段即可。 使用NAT模式虚拟机网络连接使用NAT模式，物理机网络连接使用Vmnet8。 虚拟机设置里面——网络适配器，网络连接选择NAT模式。 虚拟机菜单栏—编辑—虚拟网络编辑器，选择Vmnet8 NAT模式， 1．在最下面子网设置ip为192.168.20.0 子网掩码255.255.255.0 2．NAT设置里面网关IP为192.168.20.2 3．使用本地DHCP服务将IP地址分配给虚拟机不勾选 设置完成后点击应用退出。 CentOS 6.5 配置IP地址的三种方法 物理机网络连接VMNet8 手动设置ip地址 192.168.20.1 子网掩码255.255.255.0 网关和DNS地址为192.168.20.2（即虚拟机NAT的网关地址） 编辑linux网卡eth0的配置文件 #vi /etc/sysconfig/network-scripts/ifcfg-eth0 输入上述命令后回车，打开配置文件，使用方向键移动光标到最后一行，按字母键“O”，进入编辑模式，输入以下内容： IPADDR=192.168.25.3 NETMASK=255.255.255.0 GATEWAY=192.168.25.2 另外光标移动到”ONBOOT=no”这一行，更改为ONBOOT=yes “BOOTPROTO=dhcp”，更改为BOOTPROTO=none 完成后，按一下键盘左上角ESC键，输入:wq 在屏幕的左下方可以看到，输入回车保存配置文件。 设置DNS地址,运行命令 #vi /etc/resolv.conf 光标移动到空行，按“O”键，输入 nameserver 192.168.25.2 退出按ESC键，输入:wq 回车保存配置文件。 重启网络服务 #service network restart 重启之后 #ifconfig unzip命令安装yum install zip unzip 解压缩和压缩tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。 常用参数： -c：创建一个新tar文件 -v：显示运行过程的信息 -f：指定文件名 -z：调用gzip压缩命令进行压缩 -t：查看压缩文件的内容 -x：解开tar文件 jdk配置//打开/etc/profile文件 # vim /etc/profile 在文件末尾插入如下内容 export JAVA_HOME=/home/soft/jdk1.8.0_111 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH 最后执行 source /etc/profile 删除不询问递归删除（慎用） rm -rf a ? 不询问递归删除 rm -rf * ? 删除所有文件 管道管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。 示例 ls --help | more 分页查询帮助信息 ps –ef | grep java 查询名称中包含java的进程 ifconfig | more cat index.html | more ps –ef | grep aio 关闭防火墙entOS 6.5关闭防火墙步骤 临时关闭命令： service iptables stop 永久关闭防火墙：chkconfig iptables off 开启改为 on 两个命令同时运行，运行完成后查看防火墙关闭状态 service iptables status 出现centos yum报错Loaded plugins: fastestmirrorvi /etc/yum/pluginconf.d/fastestmirror.conf enabled = 0 vi /etc/yum.conf plugins=0 yum clean dbcache 在使用yum时如果出现：Cannot find a valid baseurl for repo: base/7/x86_64这种情况通常是，是因为没有配置DNS服务器。 解决方法：用VI编辑resolv.conf文件 命令 vi /etc/resolv.conf 添加： nameserver 114.114.114.114 国内的 wq 保存退出即可 授予权限 ///**/c: 权限不够chmod +x /**/**/**/c Redis的安装Redis是c语言开发的。 安装redis需要c语言的编译环境。如果没有gcc需要在线安装。 先查询系统中是否有gcc命令，如果出现下面提示，则表示你的系统中已经安装好了gcc命令 [root@admin ~]# gcc gcc: 没有输入文件 [root@admin ~]# make make: *** 没有指明目标并且找不到 makefile。 停止。 安装：在线，必须配置的ip地址与虚拟机网关在统一个网段 ![](https://i.imgur.com/2aWQZVJ.png) yum install gcc-c++ 安装步骤： 第一步：redis的源码包上传到linux系统。 第二步：解压缩redis。 第三步：编译。make 第四步：安装。make install PREFIX=/usr/local/redis redis的启动：前端启动：[root@localhost bin]# ./redis-server 后台启动： 把/root/redis-3.0.0/redis.conf复制到/usr/local/redis/bin目录下 [root@localhost redis-3.0.0]# cp redis.conf /usr/local/redis/bin/ 修改配置文件： [root@localhost bin]# ./redis-server redis.conf 查看redis进程： [root@localhost bin]# ps aux|grep redis root 5190 0.1 0.3 33936 1712 ? Ssl 18:23 0:00 ./redis-server *:6379 root 5196 0.0 0.1 4356 728 pts/0 S+ 18:24 0:00 grep redis [root@localhost bin]# 在使用yum命令进行安装时可能出现：Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=6&amp;arch=x86_64&amp;repo=os error was 14: PYCURL ERROR 6 - &quot;Couldn&apos;t resolve host &apos;mirrorlist.centos.org&apos;&quot; Error: Cannot find a valid baseurl for repo: base 错误，如果出现此错误： 解决：解决方法：编辑vi resolv.conf文件，添加： nameserver 8.8.8.8 cp命令cp(选项)(参数) 选项 -a：此参数的效果和同时指定&quot;-dpR&quot;参数相同； -d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录； -f：强行复制文件或目录，不论目标文件或目录是否已存在； -i：覆盖既有文件之前先询问用户； -l：对源文件建立硬连接，而非复制文件； -p：保留源文件或目录的属性； -R/r：递归处理，将指定目录下的所有文件与子目录一并处理； -s：对源文件建立符号连接，而非复制文件； -u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件； -S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀； -b：覆盖已存在的文件目标前将目标文件备份； -v：详细显示命令执行的操作。 文本编辑命令进入vi/vim的命令vi/vim filename :打开或新建文件，并将光标置于第一行首 vi/vim +n filename ：打开文件，并将光标置于第n行首 vi/vim + filename ：打开文件，并将光标置于最后一行首 vi/vim +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处 vi/vim -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename vi/vim filename….filename ：打开多个文件，依次进行编辑 屏幕翻滚类命令Ctrl+u：向文件首翻半屏 Ctrl+d：向文件尾翻半屏 Ctrl+f：向文件尾翻一屏 Ctrl＋b；向文件首翻一屏 nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。 插入文本类命令i ：在光标前 I ：在当前行首 a：光标后 A：在当前行尾 o：在当前行之下新开一行 O：在当前行之上新开一行 r：替换当前字符 R：替换当前字符及其后的字符，直至按ESC键 s：从当前光标位置处开始，以输入的文本替代指定数目的字符 S：删除指定数目的行，并以所输入文本代替之 ncw或nCW：修改指定数目的字 nCC：修改指定数目的行 删除命令ndw或ndW：删除光标处开始及其后的n-1个字 do：删至行首 d$：删至行尾 ndd：删除当前行及其后n-1行 x或X：删除一个字符，x删除光标后的，而X删除光标前的 Ctrl+u：删除输入方式下所输入的文本 搜索及替换命令/pattern：从光标开始处向文件尾搜索pattern ?pattern：从光标开始处向文件首搜索pattern n：在同一方向重复上一次搜索命令 N：在反方向上重复上一次搜索命令 ：s/p1/p2/g：将当前行中所有p1均用p2替代 ：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代 ：g/p1/s//p2/g：将文件中所有p1均用p2替换 选项设置all：列出所有选项设置情况 term：设置终端类型 ignorance：在搜索中忽略大小写 list：显示制表位(Ctrl+I)和行尾标志（$) number：显示行号 report：显示由面向行的命令修改过的数目 terse：显示简短的警告信息 warn：在转到别的文件时若没保存当前文件则显示NO write信息 nomagic：允许在搜索模式中，使用前面不带“\”的特殊字符 nowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始 mesg：允许vi显示其他用户用write写到自己终端上的信息 末行模式命令：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下 ：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下 ：n1,n2 d ：将n1行到n2行之间的内容删除 ：w ：保存当前文件 ：e filename：打开文件filename进行编辑 ：x：保存当前文件并退出 ：q：退出vi ：q!：不保存文件并退出vi ：!command：执行shell命令command ：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入 ：r!command：将命令command的输出结果放到当前行]]></content>
  </entry>
  <entry>
    <title><![CDATA[Excel解析和生成]]></title>
    <url>%2F2018%2F02%2F24%2FExcel%E8%A7%A3%E6%9E%90%E5%92%8C%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[1.导入maven坐标基于 maven 坐标导入 POI 支持 poi… jar 解析 HSSF poi ooxml .. jar 解析 XSSF （以来 POI 包 ） 解析 Excel 逻辑工作薄 --- sheet --- row --- cell 基于struts2进行文件上传的并解析 // 接收上传文件 private File file; public void setFile(File file) { this.file = file; } // 批量区域数据导入 @Action(value = &quot;area_batchImport&quot;) public String batchImport() throws IOException { //创建区域集合 List&lt;Area&gt; areas = new ArrayList&lt;Area&gt;(); // 编写解析代码逻辑 // 基于.xls 格式解析 HSSF，也可以直接使用父类Workbook,可以解析xls和xlsx // 1、 加载Excel文件对象 HSSFWorkbook hssfWorkbook = new HSSFWorkbook(new FileInputStream(file)); // 2、 读取一个sheet HSSFSheet sheet=hssfWorkbook.getSheetAt(0); // 3、 读取sheet中每一行 for (Row row : sheet) { // 一行数据 对应 一个区域对象 //根据自己导入的数据表格格式进行解析，通常第一行为表头直接跳过 if (row.getRowNum() == 0) { // 第一行 跳过 continue; } // 跳过空行 if (row.getCell(0) == null || StringUtils.isBlank(row.getCell(0).getStringCellValue())) { continue; } Area area = new Area(); area.setId(row.getCell(0).getStringCellValue()); area.setProvince(row.getCell(1).getStringCellValue()); area.setCity(row.getCell(2).getStringCellValue()); area.setDistrict(row.getCell(3).getStringCellValue()); area.setPostcode(row.getCell(4).getStringCellValue()); // 基于pinyin4j生成城市编码和简码,导入pingyin4J的坐标 String province = area.getProvince(); String city = area.getCity(); String district = area.getDistrict(); //去除省市区后缀 province = province.substring(0, province.length() - 1); city = city.substring(0, city.length() - 1); district = district.substring(0, district.length() - 1); // 简码 String[] headArray = PinYin4jUtils.getHeadByString(province + city + district); StringBuffer buffer = new StringBuffer(); for (String headStr : headArray) { buffer.append(headStr); } String shortcode = buffer.toString(); area.setShortcode(shortcode); // 城市编码 String citycode = PinYin4jUtils.hanziToPinyin(city, &quot;&quot;); area.setCitycode(citycode); areas.add(area); } // 调用业务层 areaService.saveBatch(areas); return NONE; } 生成 Excel 逻辑编写 ReportAction 添加 exportXls 方法 POI 生成 Excel 步骤写 Excel 过程一样，新建 Excel 文档 -- 新建 Sheet -- 新建 Row -- 新建 Cell 单元格 -- 写单元格数据 POI 生成 HSSF （xls）和 XSSF （xlsx） // 导出运单 报表 @Action(&quot;report_exportXls&quot;) public String exportXls() throws IOException { // 查询出 满足当前条件 结果数据 List&lt;WayBill&gt; wayBills = wayBillService.findWayBills(model); // 生成Excel文件 HSSFWorkbook hssfWorkbook = new HSSFWorkbook(); HSSFSheet sheet = hssfWorkbook.createSheet(&quot;运单数据&quot;); // 表头 HSSFRow headRow = sheet.createRow(0); headRow.createCell(0).setCellValue(&quot;运单号&quot;); headRow.createCell(1).setCellValue(&quot;寄件人&quot;); headRow.createCell(2).setCellValue(&quot;寄件人电话&quot;); headRow.createCell(3).setCellValue(&quot;寄件人地址&quot;); headRow.createCell(4).setCellValue(&quot;收件人&quot;); headRow.createCell(5).setCellValue(&quot;收件人电话&quot;); headRow.createCell(6).setCellValue(&quot;收件人地址&quot;); // 表格数据 for (WayBill wayBill : wayBills) { HSSFRow dataRow = sheet.createRow(sheet.getLastRowNum() + 1); dataRow.createCell(0).setCellValue(wayBill.getWayBillNum()); dataRow.createCell(1).setCellValue(wayBill.getSendName()); dataRow.createCell(2).setCellValue(wayBill.getSendMobile()); dataRow.createCell(3).setCellValue(wayBill.getSendAddress()); dataRow.createCell(4).setCellValue(wayBill.getRecName()); dataRow.createCell(5).setCellValue(wayBill.getRecMobile()); dataRow.createCell(6).setCellValue(wayBill.getRecAddress()); } // 下载导出 // 设置头信息 ServletActionContext.getResponse().setContentType( &quot;application/vnd.ms-excel&quot;); String filename = &quot;运单数据.xls&quot;; //设置浏览器编码 String agent = ServletActionContext.getRequest() .getHeader(&quot;user-agent&quot;); filename = FileUtils.encodeDownloadFilename(filename, agent); //设置文件头以下载形式打开 ServletActionContext.getResponse().setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + filename); ServletOutputStream outputStream = ServletActionContext.getResponse() .getOutputStream(); hssfWorkbook.write(outputStream); // 关闭 hssfWorkbook.close(); return NONE; } 生成pdf文件使用java原生代码生成pdf文件@Action(&quot;report_exportPdf&quot;) public String exportPdf() throws IOException, DocumentException { // 查询出 满足当前条件 结果数据 List&lt;WayBill&gt; wayBills = wayBillService.findWayBills(model); // 下载导出 // 设置头信息 ServletActionContext.getResponse().setContentType(&quot;application/pdf&quot;); String filename = &quot;运单数据.pdf&quot;; String agent = ServletActionContext.getRequest() .getHeader(&quot;user-agent&quot;); filename = FileUtils.encodeDownloadFilename(filename, agent); ServletActionContext.getResponse().setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + filename); // 生成PDF文件 Document document = new Document(); PdfWriter.getInstance(document, ServletActionContext.getResponse() .getOutputStream()); document.open(); // 写PDF数据 // 向document 生成pdf表格 Table table = new Table(7); table.setWidth(80); // 宽度 table.setBorder(1); // 边框 table.getDefaultCell().setHorizontalAlignment(Element.ALIGN_CENTER); // 水平对齐方式 table.getDefaultCell().setVerticalAlignment(Element.ALIGN_TOP); // 垂直对齐方式 // 设置表格字体 BaseFont cn = BaseFont.createFont(&quot;STSongStd-Light&quot;, &quot;UniGB-UCS2-H&quot;, false); Font font = new Font(cn, 10, Font.NORMAL, Color.BLUE); // 写表头 table.addCell(buildCell(&quot;运单号&quot;, font)); table.addCell(buildCell(&quot;寄件人&quot;, font)); table.addCell(buildCell(&quot;寄件人电话&quot;, font)); table.addCell(buildCell(&quot;寄件人地址&quot;, font)); table.addCell(buildCell(&quot;收件人&quot;, font)); table.addCell(buildCell(&quot;收件人电话&quot;, font)); table.addCell(buildCell(&quot;收件人地址&quot;, font)); // 写数据 for (WayBill wayBill : wayBills) { table.addCell(buildCell(wayBill.getWayBillNum(), font)); table.addCell(buildCell(wayBill.getSendName(), font)); table.addCell(buildCell(wayBill.getSendMobile(), font)); table.addCell(buildCell(wayBill.getSendAddress(), font)); table.addCell(buildCell(wayBill.getRecName(), font)); table.addCell(buildCell(wayBill.getRecMobile(), font)); table.addCell(buildCell(wayBill.getRecAddress(), font)); } // 将表格加入文档 document.add(table); document.close(); return NONE; } private Cell buildCell(String content, Font font) throws BadElementException { Phrase phrase = new Phrase(content, font); return new Cell(phrase); } 使用jasperReport技术生成pdf文件 @Action(&quot;report_exportJasperPdf&quot;) public String exportJasperPdf() throws IOException, DocumentException, JRException, SQLException { // 查询出 满足当前条件 结果数据 List&lt;WayBill&gt; wayBills = wayBillService.findWayBills(model); // 下载导出 // 设置头信息 ServletActionContext.getResponse().setContentType(&quot;application/pdf&quot;); String filename = &quot;运单数据.pdf&quot;; String agent = ServletActionContext.getRequest() .getHeader(&quot;user-agent&quot;); filename = FileUtils.encodeDownloadFilename(filename, agent); ServletActionContext.getResponse().setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + filename); // 根据 jasperReport模板 生成pdf,借助ireport工具生成模板 // 读取模板文件 String jrxml = ServletActionContext.getServletContext().getRealPath( &quot;/WEB-INF/jasper/waybill.jrxml&quot;); JasperReport report = JasperCompileManager.compileReport(jrxml); // 设置模板数据，根据模板样式来设置参数 // Parameter变量 Map&lt;String, Object&gt; paramerters = new HashMap&lt;String, Object&gt;(); paramerters.put(&quot;company&quot;, &quot;传智播客&quot;); // Field变量 JasperPrint jasperPrint = JasperFillManager.fillReport(report, paramerters, new JRBeanCollectionDataSource(wayBills)); // 生成PDF客户端 JRPdfExporter exporter = new JRPdfExporter(); exporter.setParameter(JRExporterParameter.JASPER_PRINT, jasperPrint); exporter.setParameter(JRExporterParameter.OUTPUT_STREAM, ServletActionContext.getResponse().getOutputStream()); exporter.exportReport();// 导出 ServletActionContext.getResponse().getOutputStream().close(); return NONE; } } 附加ireport工具使用IReport 报表模板简介和设置中文生成1、新建 JasperReport 模板文件 .jrxml2、设置默认语言对输入中文内容 设置组件属性 在 IReport 引入 ITextAsian.jar 字库 在工具选项中 3、 了解报表模板结构Title: 报表标题 PageHeader: 页眉 ColumnHeader: 表格列标题 Detail： 表格数据内容 ColumnFooter： 表格页脚 PageFooter： 页脚 Summary: 摘要 4、 常用报表组件 设置预览格式为 PDF 4.3． IReport 配置数据库连接，基于数据表生成报表1、 点击按钮配置数据库连接 新建 JDBC 连接 2、 在 ireport 添加 oracle 的 jdbc 驱动 3、 通过 ReportQuery 查询数据库 4、 设计报表 4.4． JasperResport 根据模板文件 生成报表1、 设置 ireport 字段 自动换行 2、 将 waybill.jrxml 复制 bos_management 3、 在 waybill_manage.html 页面添加按钮 4、 在 common-parent 导入 jasperReport 开发包 5、 在 ReportAction 添加 exportJasperPdf 方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
