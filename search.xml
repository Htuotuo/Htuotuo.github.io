<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis命令]]></title>
    <url>%2F2018%2F02%2F24%2Fredis%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[##1.Redis hash 常用命令 1、HDEL key field1 [field2] 删除一个或多个哈希表字段` 2、HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。 3、HGET key field 获取存储在哈希表中指定字段的值。` 4、HGETALL key 获取在哈希表中指定 key 的所有字段和值 5、HKEYS key 获取所有哈希表中的字段 6、HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment 。 7、HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。 8、HLEN key 获取哈希表中字段的数量 9、HMGET key field1 [field2] 获取所有给定字段的值 10、HMSET key field1 value1 [field2 value2 ] 同时将多个 field-value (域-值)对设置到哈希表 key 中。 11、HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。 12、HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。 ##2.Redis String 常用命令 1、SET key value 设置指定 key 的值 2、GET key 获取指定 key 的值。 3、GETRANGE key start end 返回 key 中字符串值的子字符 4、GETSET key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 5、GETBIT key offset 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。 6、MGET key1 [key2..] 获取所有(一个或多个)给定 key 的值。 7、SETBIT key offset value 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。 8、SETEX key seconds value 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。 9、SETNX key value 只有在 key 不存在时设置 key 的值。 10、SETRANGE key offset value 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。 11、STRLEN key 返回 key 所储存的字符串值的长度。 12、MSET key value [key value ...] 同时设置一个或多个 key-value 对。 13、MSETNX key value [key value ...] 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。 14、PSETEX key milliseconds value 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。 15、INCR key 将 key 中储存的数字值增一。 16、INCRBY key increment 将 key 所储存的值加上给定的增量值（increment） 。 17、INCRBYFLOAT key increment 将 key 所储存的值加上给定的浮点增量值（increment） 。 18、DECR key 将 key 中储存的数字值减一。 19、DECRBY key decrement key 所储存的值减去给定的减量值（decrement） 。 20、APPEND key value 如果 key 已经存在并且是一个字符串， APPEND 命令将 指定value 追加到改 key 原来的值（value）的末尾。]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux常见命令]]></title>
    <url>%2F2018%2F02%2F24%2Flinux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[##1.手动配置IP地址 ###1、自动获取IP地址 虚拟机使用桥接模式，相当于连接到物理机的网络里，物理机网络有DHCP服务器自动分配IP地址。 #dhclient 自动获取ip地址命令 #ifconfig 查询系统里网卡信息，ip地址、MAC地址 分配到ip地址后，用物理机进行ping ip地址，检测是否ping通。 ###2、手动设置ip地址 如果虚拟机不能自动获取IP，只能手动配置，配置方法如下： 输入命令 #vi /etc/sysconfig/network-scripts/ifcfg-eth0 编辑网卡的配置文件 输入上述命令后回车，打开配置文件，使用方向键移动光标到最后一行，按字母键“O”，进入编辑模式，输入以下内容： IPADDR=192.168.25.10 NETMASK=255.255.255.0 GATEWAY=192.168.25.1 另外光标移动到”ONBOOT=no”这一行，更改为ONBOOT=yes “BOOTPROTO=dhcp”，更改为BOOTPROTO=none 完成后，按一下键盘左上角ESC键，输入:wq 在屏幕的左下方可以看到，输入回车保存配置文件。 之后需要重启一下网络服务，命令为 #service network restart 网络重启后，eth0的ip就生效了，使用命令#ifconfigeth0 查看 接下来检测配置的IP是否可以ping通，在物理机使用快捷键WINDOWS+R 打开运行框，输入命令cmd，输入ping 192.168.4.10 进行检测，ping通说明IP配置正确。 备注：我所在的物理机网段为192.168.4.0 网段。大家做实验的时候根据自己的环境进行设定，保持虚拟机和物理机在同一网段即可。 ###3、使用NAT模式 虚拟机网络连接使用NAT模式，物理机网络连接使用Vmnet8。 虚拟机设置里面——网络适配器，网络连接选择NAT模式。 虚拟机菜单栏—编辑—虚拟网络编辑器，选择Vmnet8 NAT模式， 1．在最下面子网设置ip为192.168.20.0 子网掩码255.255.255.0 2．NAT设置里面网关IP为192.168.20.2 3．使用本地DHCP服务将IP地址分配给虚拟机不勾选 设置完成后点击应用退出。 CentOS 6.5 配置IP地址的三种方法 物理机网络连接VMNet8 手动设置ip地址 192.168.20.1 子网掩码255.255.255.0 网关和DNS地址为192.168.20.2（即虚拟机NAT的网关地址） 编辑linux网卡eth0的配置文件 #vi /etc/sysconfig/network-scripts/ifcfg-eth0 输入上述命令后回车，打开配置文件，使用方向键移动光标到最后一行，按字母键“O”，进入编辑模式，输入以下内容： IPADDR=192.168.25.3 NETMASK=255.255.255.0 GATEWAY=192.168.25.2 另外光标移动到”ONBOOT=no”这一行，更改为ONBOOT=yes “BOOTPROTO=dhcp”，更改为BOOTPROTO=none 完成后，按一下键盘左上角ESC键，输入:wq 在屏幕的左下方可以看到，输入回车保存配置文件。 设置DNS地址,运行命令 #vi /etc/resolv.conf 光标移动到空行，按“O”键，输入 nameserver 192.168.25.2 退出按ESC键，输入:wq 回车保存配置文件。 重启网络服务 #service network restart 重启之后 #ifconfig ##2.unzip命令安装 yum install zip unzip ##3.解压缩和压缩 tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。 常用参数： -c：创建一个新tar文件 -v：显示运行过程的信息 -f：指定文件名 -z：调用gzip压缩命令进行压缩 -t：查看压缩文件的内容 -x：解开tar文件 ##4.jdk配置 //打开/etc/profile文件 # vim /etc/profile 在文件末尾插入如下内容 export JAVA_HOME=/home/soft/jdk1.8.0_111 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH 最后执行 source /etc/profile ##5.删除 不询问递归删除（慎用） rm -rf a ? 不询问递归删除 rm -rf * ? 删除所有文件 ##6.管道 管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。 示例 ls –help | more 分页查询帮助信息 ps –ef | grep java 查询名称中包含java的进程 ifconfig | more cat index.html | more ps –ef | grep aio ##7.关闭防火墙 entOS 6.5关闭防火墙步骤 临时关闭命令： service iptables stop 永久关闭防火墙：chkconfig iptables off 开启改为 on 两个命令同时运行，运行完成后查看防火墙关闭状态 service iptables status ##8.出现centos yum报错Loaded plugins: fastestmirror vi /etc/yum/pluginconf.d/fastestmirror.conf enabled = 0 vi /etc/yum.conf plugins=0 yum clean dbcache ##9.在使用yum时如果出现：Cannot find a valid baseurl for repo: base/7/x86_64 这种情况通常是，是因为没有配置DNS服务器。 解决方法：用VI编辑resolv.conf文件 命令 vi /etc/resolv.conf 添加： nameserver 114.114.114.114 国内的 wq 保存退出即可 ##10.授予权限 ///**/c: 权限不够 chmod +x /**/**/**/c ##11.Redis的安装 Redis是c语言开发的。 安装redis需要c语言的编译环境。如果没有gcc需要在线安装。 先查询系统中是否有gcc命令，如果出现下面提示，则表示你的系统中已经安装好了gcc命令 [root@admin ~]# gcc gcc: 没有输入文件 [root@admin ~]# make make: *** 没有指明目标并且找不到 makefile。 停止。 安装：在线，必须配置的ip地址与虚拟机网关在统一个网段 ![](https://i.imgur.com/2aWQZVJ.png) yum install gcc-c++ 安装步骤： 第一步：redis的源码包上传到linux系统。 第二步：解压缩redis。 第三步：编译。make 第四步：安装。make install PREFIX=/usr/local/redis redis的启动：前端启动：[root@localhost bin]# ./redis-server 后台启动： 把/root/redis-3.0.0/redis.conf复制到/usr/local/redis/bin目录下 [root@localhost redis-3.0.0]# cp redis.conf /usr/local/redis/bin/ 修改配置文件： [root@localhost bin]# ./redis-server redis.conf 查看redis进程： [root@localhost bin]# ps aux|grep redis root 5190 0.1 0.3 33936 1712 ? Ssl 18:23 0:00 ./redis-server *:6379 root 5196 0.0 0.1 4356 728 pts/0 S+ 18:24 0:00 grep redis [root@localhost bin]# ##在使用yum命令进行安装时可能出现： Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=6&amp;arch=x86_64&amp;repo=os error was 14: PYCURL ERROR 6 - “Couldn’t resolve host ‘mirrorlist.centos.org’” Error: Cannot find a valid baseurl for repo: base 错误，如果出现此错误： 解决：解决方法：编辑vi resolv.conf文件，添加： nameserver 8.8.8.8 ##cp命令 cp(选项)(参数) 选项 -a：此参数的效果和同时指定&quot;-dpR&quot;参数相同； -d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录； -f：强行复制文件或目录，不论目标文件或目录是否已存在； -i：覆盖既有文件之前先询问用户； -l：对源文件建立硬连接，而非复制文件； -p：保留源文件或目录的属性； -R/r：递归处理，将指定目录下的所有文件与子目录一并处理； -s：对源文件建立符号连接，而非复制文件； -u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件； -S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀； -b：覆盖已存在的文件目标前将目标文件备份； -v：详细显示命令执行的操作。 ##文本编辑命令 ###进入vi/vim的命令 vi/vim filename :打开或新建文件，并将光标置于第一行首 vi/vim +n filename ：打开文件，并将光标置于第n行首 vi/vim + filename ：打开文件，并将光标置于最后一行首 vi/vim +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处 vi/vim -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename vi/vim filename….filename ：打开多个文件，依次进行编辑 ###屏幕翻滚类命令 Ctrl+u：向文件首翻半屏 Ctrl+d：向文件尾翻半屏 Ctrl+f：向文件尾翻一屏 Ctrl＋b；向文件首翻一屏 nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。 ###插入文本类命令 i ：在光标前 I ：在当前行首 a：光标后 A：在当前行尾 o：在当前行之下新开一行 O：在当前行之上新开一行 r：替换当前字符 R：替换当前字符及其后的字符，直至按ESC键 s：从当前光标位置处开始，以输入的文本替代指定数目的字符 S：删除指定数目的行，并以所输入文本代替之 ncw或nCW：修改指定数目的字 nCC：修改指定数目的行 ###删除命令 ndw或ndW：删除光标处开始及其后的n-1个字 do：删至行首 d$：删至行尾 ndd：删除当前行及其后n-1行 x或X：删除一个字符，x删除光标后的，而X删除光标前的 Ctrl+u：删除输入方式下所输入的文本 ###搜索及替换命令 /pattern：从光标开始处向文件尾搜索pattern ?pattern：从光标开始处向文件首搜索pattern n：在同一方向重复上一次搜索命令 N：在反方向上重复上一次搜索命令 ：s/p1/p2/g：将当前行中所有p1均用p2替代 ：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代 ：g/p1/s//p2/g：将文件中所有p1均用p2替换 ###选项设置 all：列出所有选项设置情况 term：设置终端类型 ignorance：在搜索中忽略大小写 list：显示制表位(Ctrl+I)和行尾标志（$) number：显示行号 report：显示由面向行的命令修改过的数目 terse：显示简短的警告信息 warn：在转到别的文件时若没保存当前文件则显示NO write信息 nomagic：允许在搜索模式中，使用前面不带“\”的特殊字符 nowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始 mesg：允许vi显示其他用户用write写到自己终端上的信息 ###末行模式命令 ：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下 ：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下 ：n1,n2 d ：将n1行到n2行之间的内容删除 ：w ：保存当前文件 ：e filename：打开文件filename进行编辑 ：x：保存当前文件并退出 ：q：退出vi ：q!：不保存文件并退出vi ：!command：执行shell命令command ：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入 ：r!command：将命令command的输出结果放到当前行]]></content>
  </entry>
  <entry>
    <title><![CDATA[Excel解析和生成]]></title>
    <url>%2F2018%2F02%2F24%2FExcel%E8%A7%A3%E6%9E%90%E5%92%8C%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[1.导入maven坐标基于 maven 坐标导入 POI 支持 poi… jar 解析 HSSF poi ooxml .. jar 解析 XSSF （以来 POI 包 ） 解析 Excel 逻辑工作薄 --- sheet --- row --- cell 基于struts2进行文件上传的并解析 // 接收上传文件 private File file; public void setFile(File file) { this.file = file; } // 批量区域数据导入 @Action(value = &quot;area_batchImport&quot;) public String batchImport() throws IOException { //创建区域集合 List&lt;Area&gt; areas = new ArrayList&lt;Area&gt;(); // 编写解析代码逻辑 // 基于.xls 格式解析 HSSF，也可以直接使用父类Workbook,可以解析xls和xlsx // 1、 加载Excel文件对象 HSSFWorkbook hssfWorkbook = new HSSFWorkbook(new FileInputStream(file)); // 2、 读取一个sheet HSSFSheet sheet=hssfWorkbook.getSheetAt(0); // 3、 读取sheet中每一行 for (Row row : sheet) { // 一行数据 对应 一个区域对象 //根据自己导入的数据表格格式进行解析，通常第一行为表头直接跳过 if (row.getRowNum() == 0) { // 第一行 跳过 continue; } // 跳过空行 if (row.getCell(0) == null || StringUtils.isBlank(row.getCell(0).getStringCellValue())) { continue; } Area area = new Area(); area.setId(row.getCell(0).getStringCellValue()); area.setProvince(row.getCell(1).getStringCellValue()); area.setCity(row.getCell(2).getStringCellValue()); area.setDistrict(row.getCell(3).getStringCellValue()); area.setPostcode(row.getCell(4).getStringCellValue()); // 基于pinyin4j生成城市编码和简码,导入pingyin4J的坐标 String province = area.getProvince(); String city = area.getCity(); String district = area.getDistrict(); //去除省市区后缀 province = province.substring(0, province.length() - 1); city = city.substring(0, city.length() - 1); district = district.substring(0, district.length() - 1); // 简码 String[] headArray = PinYin4jUtils.getHeadByString(province + city + district); StringBuffer buffer = new StringBuffer(); for (String headStr : headArray) { buffer.append(headStr); } String shortcode = buffer.toString(); area.setShortcode(shortcode); // 城市编码 String citycode = PinYin4jUtils.hanziToPinyin(city, &quot;&quot;); area.setCitycode(citycode); areas.add(area); } // 调用业务层 areaService.saveBatch(areas); return NONE; } 生成 Excel 逻辑编写 ReportAction 添加 exportXls 方法 POI 生成 Excel 步骤写 Excel 过程一样，新建 Excel 文档 -- 新建 Sheet -- 新建 Row -- 新建 Cell 单元格 -- 写单元格数据 POI 生成 HSSF （xls）和 XSSF （xlsx） // 导出运单 报表 @Action(&quot;report_exportXls&quot;) public String exportXls() throws IOException { // 查询出 满足当前条件 结果数据 List&lt;WayBill&gt; wayBills = wayBillService.findWayBills(model); // 生成Excel文件 HSSFWorkbook hssfWorkbook = new HSSFWorkbook(); HSSFSheet sheet = hssfWorkbook.createSheet(&quot;运单数据&quot;); // 表头 HSSFRow headRow = sheet.createRow(0); headRow.createCell(0).setCellValue(&quot;运单号&quot;); headRow.createCell(1).setCellValue(&quot;寄件人&quot;); headRow.createCell(2).setCellValue(&quot;寄件人电话&quot;); headRow.createCell(3).setCellValue(&quot;寄件人地址&quot;); headRow.createCell(4).setCellValue(&quot;收件人&quot;); headRow.createCell(5).setCellValue(&quot;收件人电话&quot;); headRow.createCell(6).setCellValue(&quot;收件人地址&quot;); // 表格数据 for (WayBill wayBill : wayBills) { HSSFRow dataRow = sheet.createRow(sheet.getLastRowNum() + 1); dataRow.createCell(0).setCellValue(wayBill.getWayBillNum()); dataRow.createCell(1).setCellValue(wayBill.getSendName()); dataRow.createCell(2).setCellValue(wayBill.getSendMobile()); dataRow.createCell(3).setCellValue(wayBill.getSendAddress()); dataRow.createCell(4).setCellValue(wayBill.getRecName()); dataRow.createCell(5).setCellValue(wayBill.getRecMobile()); dataRow.createCell(6).setCellValue(wayBill.getRecAddress()); } // 下载导出 // 设置头信息 ServletActionContext.getResponse().setContentType( &quot;application/vnd.ms-excel&quot;); String filename = &quot;运单数据.xls&quot;; //设置浏览器编码 String agent = ServletActionContext.getRequest() .getHeader(&quot;user-agent&quot;); filename = FileUtils.encodeDownloadFilename(filename, agent); //设置文件头以下载形式打开 ServletActionContext.getResponse().setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + filename); ServletOutputStream outputStream = ServletActionContext.getResponse() .getOutputStream(); hssfWorkbook.write(outputStream); // 关闭 hssfWorkbook.close(); return NONE; } ##生成pdf文件 ###使用java原生代码生成pdf文件 @Action(“report_exportPdf”) public String exportPdf() throws IOException, DocumentException { // 查询出 满足当前条件 结果数据 List wayBills = wayBillService.findWayBills(model); // 下载导出 // 设置头信息 ServletActionContext.getResponse().setContentType(&quot;application/pdf&quot;); String filename = &quot;运单数据.pdf&quot;; String agent = ServletActionContext.getRequest() .getHeader(&quot;user-agent&quot;); filename = FileUtils.encodeDownloadFilename(filename, agent); ServletActionContext.getResponse().setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + filename); // 生成PDF文件 Document document = new Document(); PdfWriter.getInstance(document, ServletActionContext.getResponse() .getOutputStream()); document.open(); // 写PDF数据 // 向document 生成pdf表格 Table table = new Table(7); table.setWidth(80); // 宽度 table.setBorder(1); // 边框 table.getDefaultCell().setHorizontalAlignment(Element.ALIGN_CENTER); // 水平对齐方式 table.getDefaultCell().setVerticalAlignment(Element.ALIGN_TOP); // 垂直对齐方式 // 设置表格字体 BaseFont cn = BaseFont.createFont(&quot;STSongStd-Light&quot;, &quot;UniGB-UCS2-H&quot;, false); Font font = new Font(cn, 10, Font.NORMAL, Color.BLUE); // 写表头 table.addCell(buildCell(&quot;运单号&quot;, font)); table.addCell(buildCell(&quot;寄件人&quot;, font)); table.addCell(buildCell(&quot;寄件人电话&quot;, font)); table.addCell(buildCell(&quot;寄件人地址&quot;, font)); table.addCell(buildCell(&quot;收件人&quot;, font)); table.addCell(buildCell(&quot;收件人电话&quot;, font)); table.addCell(buildCell(&quot;收件人地址&quot;, font)); // 写数据 for (WayBill wayBill : wayBills) { table.addCell(buildCell(wayBill.getWayBillNum(), font)); table.addCell(buildCell(wayBill.getSendName(), font)); table.addCell(buildCell(wayBill.getSendMobile(), font)); table.addCell(buildCell(wayBill.getSendAddress(), font)); table.addCell(buildCell(wayBill.getRecName(), font)); table.addCell(buildCell(wayBill.getRecMobile(), font)); table.addCell(buildCell(wayBill.getRecAddress(), font)); } // 将表格加入文档 document.add(table); document.close(); return NONE; } private Cell buildCell(String content, Font font) throws BadElementException { Phrase phrase = new Phrase(content, font); return new Cell(phrase); } ###使用jasperReport技术生成pdf文件 @Action(“report_exportJasperPdf”) public String exportJasperPdf() throws IOException, DocumentException, JRException, SQLException { // 查询出 满足当前条件 结果数据 List wayBills = wayBillService.findWayBills(model); // 下载导出 // 设置头信息 ServletActionContext.getResponse().setContentType(&quot;application/pdf&quot;); String filename = &quot;运单数据.pdf&quot;; String agent = ServletActionContext.getRequest() .getHeader(&quot;user-agent&quot;); filename = FileUtils.encodeDownloadFilename(filename, agent); ServletActionContext.getResponse().setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + filename); // 根据 jasperReport模板 生成pdf,借助ireport工具生成模板 // 读取模板文件 String jrxml = ServletActionContext.getServletContext().getRealPath( &quot;/WEB-INF/jasper/waybill.jrxml&quot;); JasperReport report = JasperCompileManager.compileReport(jrxml); // 设置模板数据，根据模板样式来设置参数 // Parameter变量 Map&lt;String, Object&gt; paramerters = new HashMap&lt;String, Object&gt;(); paramerters.put(&quot;company&quot;, &quot;传智播客&quot;); // Field变量 JasperPrint jasperPrint = JasperFillManager.fillReport(report, paramerters, new JRBeanCollectionDataSource(wayBills)); // 生成PDF客户端 JRPdfExporter exporter = new JRPdfExporter(); exporter.setParameter(JRExporterParameter.JASPER_PRINT, jasperPrint); exporter.setParameter(JRExporterParameter.OUTPUT_STREAM, ServletActionContext.getResponse().getOutputStream()); exporter.exportReport();// 导出 ServletActionContext.getResponse().getOutputStream().close(); return NONE; } } ##附加ireport工具使用 ##IReport 报表模板简介和设置中文生成 ###1、 新建 JasperReport 模板文件 .jrxml ###2、 设置默认语言 对输入中文内容 设置组件属性 在 IReport 引入 ITextAsian.jar 字库 在工具选项中 ###3、 了解报表模板结构 Title: 报表标题 PageHeader: 页眉 ColumnHeader: 表格列标题 Detail： 表格数据内容 ColumnFooter： 表格页脚 PageFooter： 页脚 Summary: 摘要 ###4、 常用报表组件 设置预览格式为 PDF ##4.3． IReport 配置数据库连接，基于数据表生成报表 1、 点击按钮配置数据库连接 新建 JDBC 连接 2、 在 ireport 添加 oracle 的 jdbc 驱动 3、 通过 ReportQuery 查询数据库 4、 设计报表 ##4.4． JasperResport 根据模板文件 生成报表 1、 设置 ireport 字段 自动换行 2、 将 waybill.jrxml 复制 bos_management 3、 在 waybill_manage.html 页面添加按钮 4、 在 common-parent 导入 jasperReport 开发包 5、 在 ReportAction 添加 exportJasperPdf 方法]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F02%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
