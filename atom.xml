<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tuotuo的博客</title>
  
  <subtitle>tuotuo</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://htuotuo.top/"/>
  <updated>2018-02-27T01:33:41.379Z</updated>
  <id>http://htuotuo.top/</id>
  
  <author>
    <name>tuotuo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux常见问题整合</title>
    <link href="http://htuotuo.top/2018/02/27/linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://htuotuo.top/2018/02/27/linux常见问题/</id>
    <published>2018-02-27T01:30:10.607Z</published>
    <updated>2018-02-27T01:33:41.379Z</updated>
    
    <content type="html"><![CDATA[<p>##1.手动配置IP地址<br>*1、自动获取IP地址<br>    虚拟机使用桥接模式，相当于连接到物理机的网络里，物理机网络有DHCP服务器自动分配IP地址。</p><pre><code>#dhclient 自动获取ip地址命令#ifconfig 查询系统里网卡信息，ip地址、MAC地址分配到ip地址后，用物理机进行ping ip地址，检测是否ping通。</code></pre><p>*2、手动设置ip地址</p><pre><code>如果虚拟机不能自动获取IP，只能手动配置，配置方法如下：输入命令#vi /etc/sysconfig/network-scripts/ifcfg-eth0编辑网卡的配置文件输入上述命令后回车，打开配置文件，使用方向键移动光标到最后一行，按字母键“O”，进入编辑模式，输入以下内容：IPADDR=192.168.25.10NETMASK=255.255.255.0GATEWAY=192.168.25.1另外光标移动到”ONBOOT=no”这一行，更改为ONBOOT=yes“BOOTPROTO=dhcp”，更改为BOOTPROTO=none完成后，按一下键盘左上角ESC键，输入:wq 在屏幕的左下方可以看到，输入回车保存配置文件。之后需要重启一下网络服务，命令为#service network restart网络重启后，eth0的ip就生效了，使用命令#ifconfigeth0 查看接下来检测配置的IP是否可以ping通，在物理机使用快捷键WINDOWS+R 打开运行框，输入命令cmd，输入ping 192.168.4.10 进行检测，ping通说明IP配置正确。备注：我所在的物理机网段为192.168.4.0 网段。大家做实验的时候根据自己的环境进行设定，保持虚拟机和物理机在同一网段即可。</code></pre><p>*3、使用NAT模式</p><pre><code>虚拟机网络连接使用NAT模式，物理机网络连接使用Vmnet8。虚拟机设置里面——网络适配器，网络连接选择NAT模式。虚拟机菜单栏—编辑—虚拟网络编辑器，选择Vmnet8 NAT模式，1．在最下面子网设置ip为192.168.20.0 子网掩码255.255.255.02．NAT设置里面网关IP为192.168.20.23．使用本地DHCP服务将IP地址分配给虚拟机不勾选设置完成后点击应用退出。CentOS 6.5 配置IP地址的三种方法物理机网络连接VMNet8 手动设置ip地址 192.168.20.1 子网掩码255.255.255.0网关和DNS地址为192.168.20.2（即虚拟机NAT的网关地址）编辑linux网卡eth0的配置文件#vi /etc/sysconfig/network-scripts/ifcfg-eth0输入上述命令后回车，打开配置文件，使用方向键移动光标到最后一行，按字母键“O”，进入编辑模式，输入以下内容：IPADDR=192.168.25.3NETMASK=255.255.255.0GATEWAY=192.168.25.2另外光标移动到”ONBOOT=no”这一行，更改为ONBOOT=yes“BOOTPROTO=dhcp”，更改为BOOTPROTO=none完成后，按一下键盘左上角ESC键，输入:wq 在屏幕的左下方可以看到，输入回车保存配置文件。设置DNS地址,运行命令#vi /etc/resolv.conf光标移动到空行，按“O”键，输入 nameserver 192.168.25.2 退出按ESC键，输入:wq 回车保存配置文件。重启网络服务#service network restart重启之后#ifconfig</code></pre><p>##2.unzip命令安装<br>    yum install zip unzip</p><p>##3.解压缩和压缩<br>    tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。</p><pre><code>常用参数：-c：创建一个新tar文件-v：显示运行过程的信息-f：指定文件名-z：调用gzip压缩命令进行压缩-t：查看压缩文件的内容-x：解开tar文件</code></pre><p>##4.jdk配置<br>    //打开/etc/profile文件</p><pre><code># vim /etc/profile在文件末尾插入如下内容export JAVA_HOME=/home/soft/jdk1.8.0_111 export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH最后执行 source /etc/profile</code></pre><p>##5.删除<br>    不询问递归删除（慎用）<br>    rm -rf  a  ?  不询问递归删除<br>    rm -rf *   ?   删除所有文件</p><p>##6.管道<br>    管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。<br>    示例<br>    ls –help | more  分页查询帮助信息<br>    ps –ef | grep java  查询名称中包含java的进程</p><pre><code>ifconfig | morecat index.html | moreps –ef | grep aio</code></pre><p>##7.关闭防火墙<br>    entOS 6.5关闭防火墙步骤</p><pre><code>临时关闭命令：  service iptables stop 永久关闭防火墙：chkconfig iptables off开启改为 on两个命令同时运行，运行完成后查看防火墙关闭状态 service iptables status</code></pre><p>##8.出现centos yum报错Loaded plugins: fastestmirror </p><pre><code>vi /etc/yum/pluginconf.d/fastestmirror.conf enabled = 0vi /etc/yum.confplugins=0yum clean dbcache</code></pre><p>##9.在使用yum时如果出现：Cannot find a valid baseurl for repo: base/7/x86_64<br>    这种情况通常是，是因为没有配置DNS服务器。</p><pre><code>解决方法：用VI编辑resolv.conf文件命令vi /etc/resolv.conf添加：nameserver 114.114.114.114    国内的wq保存退出即可</code></pre><p>##10.授予权限  /<strong>/</strong>/**/c: 权限不够</p><pre><code>chmod +x /**/**/**/c</code></pre><p>##11.Redis的安装<br>    Redis是c语言开发的。<br>    安装redis需要c语言的编译环境。如果没有gcc需要在线安装。</p><pre><code>先查询系统中是否有gcc命令，如果出现下面提示，则表示你的系统中已经安装好了gcc命令    [root@admin ~]# gccgcc: 没有输入文件[root@admin ~]# makemake: *** 没有指明目标并且找不到 makefile。 停止。安装：在线，必须配置的ip地址与虚拟机网关在统一个网段![](https://i.imgur.com/2aWQZVJ.png)yum install gcc-c++安装步骤：第一步：redis的源码包上传到linux系统。第二步：解压缩redis。第三步：编译。make 第四步：安装。make install PREFIX=/usr/local/redis</code></pre><h3 id="redis的启动："><a href="#redis的启动：" class="headerlink" title="redis的启动："></a>redis的启动：</h3><pre><code>前端启动：[root@localhost bin]# ./redis-server 后台启动：把/root/redis-3.0.0/redis.conf复制到/usr/local/redis/bin目录下[root@localhost redis-3.0.0]# cp redis.conf /usr/local/redis/bin/修改配置文件：[root@localhost bin]# ./redis-server redis.conf查看redis进程：[root@localhost bin]# ps aux|grep redisroot      5190  0.1  0.3  33936  1712 ?        Ssl  18:23   0:00 ./redis-server *:6379    root      5196  0.0  0.1   4356   728 pts/0    S+   18:24   0:00 grep redis[root@localhost bin]# </code></pre><p>##在使用yum命令进行安装时可能出现：<br>    Could not retrieve mirrorlist <a href="http://mirrorlist.centos.org/?release=6&amp;arch=x86_64&amp;repo=os" target="_blank" rel="noopener">http://mirrorlist.centos.org/?release=6&amp;arch=x86_64&amp;repo=os</a> error was<br>    14: PYCURL ERROR 6 - “Couldn’t resolve host ‘mirrorlist.centos.org’”<br>    Error: Cannot find a valid baseurl for repo: base<br>    错误，如果出现此错误：</p><pre><code>解决：解决方法：编辑vi resolv.conf文件，添加：nameserver 8.8.8.8 </code></pre><p>##cp命令<br>    cp(选项)(参数)</p><pre><code>选项-a：此参数的效果和同时指定&quot;-dpR&quot;参数相同；-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；-f：强行复制文件或目录，不论目标文件或目录是否已存在；-i：覆盖既有文件之前先询问用户；-l：对源文件建立硬连接，而非复制文件；-p：保留源文件或目录的属性；-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；-s：对源文件建立符号连接，而非复制文件；-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；-b：覆盖已存在的文件目标前将目标文件备份；-v：详细显示命令执行的操作。</code></pre><p>##文本编辑命令</p><p>###进入vi/vim的命令<br>    vi/vim filename :打开或新建文件，并将光标置于第一行首<br>    vi/vim +n filename ：打开文件，并将光标置于第n行首<br>    vi/vim + filename ：打开文件，并将光标置于最后一行首<br>    vi/vim +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处<br>    vi/vim -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filename<br>    vi/vim filename….filename ：打开多个文件，依次进行编辑</p><p>###屏幕翻滚类命令<br>    Ctrl+u：向文件首翻半屏<br>    Ctrl+d：向文件尾翻半屏<br>    Ctrl+f：向文件尾翻一屏<br>    Ctrl＋b；向文件首翻一屏<br>    nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。</p><p>###插入文本类命令<br>    i ：在光标前<br>    I ：在当前行首<br>    a：光标后<br>    A：在当前行尾<br>    o：在当前行之下新开一行<br>    O：在当前行之上新开一行<br>    r：替换当前字符<br>    R：替换当前字符及其后的字符，直至按ESC键<br>    s：从当前光标位置处开始，以输入的文本替代指定数目的字符<br>    S：删除指定数目的行，并以所输入文本代替之<br>    ncw或nCW：修改指定数目的字<br>    nCC：修改指定数目的行</p><p>###删除命令<br>    ndw或ndW：删除光标处开始及其后的n-1个字<br>    do：删至行首<br>    d$：删至行尾<br>    ndd：删除当前行及其后n-1行<br>    x或X：删除一个字符，x删除光标后的，而X删除光标前的<br>    Ctrl+u：删除输入方式下所输入的文本</p><p>###搜索及替换命令<br>    /pattern：从光标开始处向文件尾搜索pattern<br>    ?pattern：从光标开始处向文件首搜索pattern<br>    n：在同一方向重复上一次搜索命令<br>    N：在反方向上重复上一次搜索命令<br>    ：s/p1/p2/g：将当前行中所有p1均用p2替代<br>    ：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代<br>    ：g/p1/s//p2/g：将文件中所有p1均用p2替换</p><p>###选项设置<br>    all：列出所有选项设置情况<br>    term：设置终端类型<br>    ignorance：在搜索中忽略大小写<br>    list：显示制表位(Ctrl+I)和行尾标志（$)<br>    number：显示行号<br>    report：显示由面向行的命令修改过的数目<br>    terse：显示简短的警告信息<br>    warn：在转到别的文件时若没保存当前文件则显示NO write信息<br>    nomagic：允许在搜索模式中，使用前面不带“\”的特殊字符<br>    nowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始<br>    mesg：允许vi显示其他用户用write写到自己终端上的信息</p><p>###末行模式命令<br>    ：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下<br>    ：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下<br>    ：n1,n2 d ：将n1行到n2行之间的内容删除<br>    ：w ：保存当前文件<br>    ：e filename：打开文件filename进行编辑<br>    ：x：保存当前文件并退出<br>    ：q：退出vi<br>    ：q!：不保存文件并退出vi<br>    ：!command：执行shell命令command<br>    ：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入<br>    ：r!command：将命令command的输出结果放到当前行 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##1.手动配置IP地址&lt;br&gt;*1、自动获取IP地址&lt;br&gt;    虚拟机使用桥接模式，相当于连接到物理机的网络里，物理机网络有DHCP服务器自动分配IP地址。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#dhclient 自动获取ip地址命令
#ifconfig 查询系统里网卡信息
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ActiveMQ队列</title>
    <link href="http://htuotuo.top/2018/02/25/ActiveMQ%E9%98%9F%E5%88%97/"/>
    <id>http://htuotuo.top/2018/02/25/ActiveMQ队列/</id>
    <published>2018-02-25T05:31:30.307Z</published>
    <updated>2018-02-26T03:32:37.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ActiveMQ-的作用分析"><a href="#ActiveMQ-的作用分析" class="headerlink" title="ActiveMQ 的作用分析"></a>ActiveMQ 的作用分析</h2><pre><code>ActiveMQ对列与webservice之间的区别：    相同：都可以用于不同系统之间的通讯    不同：ActiveMQ是异步，webservice是同步的         ActiveMQ有生产者和消费者，生产者生产，而消费者只负责监听消费，无需在发送响应之后等待，而webservice则需在发送响应后等待响应结果。</code></pre><h3 id="ActiveMQ-工作原理"><a href="#ActiveMQ-工作原理" class="headerlink" title="ActiveMQ 工作原理"></a>ActiveMQ 工作原理</h3><p><img src="https://i.imgur.com/yPDblmh.png" alt=""></p><pre><code>1、 解决服务之间耦合2、 使用消息队列，增加系统并发处理量ActiveMQ 应用场景分析1、 用户注册，重点用户信息数据库保存，发短信、发邮件，增加业务处理复杂度，这时候使用 MQ， 将发短信、发邮箱，通知 MQ，由另外服务平台完成2、 搜索平台、缓存平台查询数据，建立缓存、索引 ，不从数据库查询，从缓存或者索引库查询当增加、修改、删除数据时，发送消息给 MQ， 缓存平台、索引平台 从 MQ 获取到这个信息，更新缓存或者索引 </code></pre><h2 id="ActiveMQ-安装和使用"><a href="#ActiveMQ-安装和使用" class="headerlink" title="ActiveMQ 安装和使用"></a>ActiveMQ 安装和使用</h2><p><a href="http://activemq.apache.org/" target="_blank" rel="noopener">    官网： http://activemq.apache.org/</a></p><pre><code>进行 apache-activemq-5.14.0\bin\win64 目录 启动 activemq.bat 文件访问： http://localhost:8161/ 用户名和密码 都是 adminactiveMQ 使用的是标准生产者和消费者模型有两种数据结构 Queue、 Topic1、 Queue 队列 ，生产者生产了一个消息，只能由一个消费者进行消费2、 Topic 话题，生产者生产了一个消息，可以由多个消费者进行消费</code></pre><h2 id="使用-Java-程序操作-ActiveMQ（了解）"><a href="#使用-Java-程序操作-ActiveMQ（了解）" class="headerlink" title="使用 Java 程序操作 ActiveMQ（了解）"></a>使用 Java 程序操作 ActiveMQ（了解）</h2><pre><code>1、 开发 activeMQ 只需要导入 activemq-all-5.14.0.jar使用 maven 坐标2、 编写 MQ 消息生产者使用步骤：第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。第二步：使用ConnectionFactory对象创建一个Connection对象。第三步：开启连接，调用Connection对象的start方法。第四步：使用Connection对象创建一个Session对象。第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Topic对象。第六步：使用Session对象创建一个Producer对象。第七步：创建一个Message对象，创建一个TextMessage对象。第八步：使用Producer对象发送消息。第九步：关闭资源。</code></pre><p><img src="https://i.imgur.com/FVbY7sW.png" alt=""></p><pre><code>默认 tcp 连接 activeMQ 端口 61616 ！！！3、 编写 MQ 消费者代码消费者：接收消息。第一步：创建一个ConnectionFactory对象。第二步：从ConnectionFactory对象中获得一个Connection对象。第三步：开启连接。调用Connection对象的start方法。第四步：使用Connection对象创建一个Session对象。第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。第六步：使用Session对象创建一个Consumer对象。第七步：接收消息。第八步：打印消息。第九步：关闭资源a) 使用 MessageConsumer 完成消费</code></pre><p><img src="https://i.imgur.com/HJQg3sc.png" alt=""></p><pre><code>b) 使用监听器，监听消息的内容，进行消费</code></pre><p><img src="https://i.imgur.com/m0Kx8da.png" alt=""></p><p><strong>注意：在linux服务器中配置activeMQ访问页面如果出现503问题</strong></p><pre><code>解决方法：在linux中查看自己的主机名是否为localhost，如果不为localhost就需要使用 vim /ect/hosts 将自己主机名字添加在 localhost4这一行最后，添加自己的主机名保存即可</code></pre><h2 id="结合-spring-完成-ActiveMQ-编程"><a href="#结合-spring-完成-ActiveMQ-编程" class="headerlink" title="结合 spring 完成 ActiveMQ 编程"></a>结合 spring 完成 ActiveMQ 编程</h2><pre><code>1.在 activeMQ_spring 导入相关 jar 包，导入maven坐标</code></pre><p><img src="https://i.imgur.com/u7Jm2vX.png" alt=""></p><pre><code>2、 编写配置生产者配置 activemq 连接工厂使用此方式需要连接网络加载名称空间，一般使用原生的配置    </code></pre><p><img src="https://i.imgur.com/xExYQqE.png" alt=""></p><pre><code>配置 spring mq 管理工厂</code></pre><p><img src="https://i.imgur.com/5sCfpE0.png" alt=""></p><pre><code>配置 jmsTemplate 模板，有两种方式，使用一种即可</code></pre><p><img src="https://i.imgur.com/8M0tPru.png" alt=""></p><pre><code>完成代码</code></pre><p><img src="https://i.imgur.com/O0G8hz9.png" alt=""></p><pre><code>3、 编写消费者代码配置只扫描 consumer 包，topic跟queue队列相同，但topic是一对多mapMessage和textMessage mapMessage是key-value的形式</code></pre><p><img src="https://i.imgur.com/BJ6LfY5.png" alt=""></p><pre><code>配置 listener 监听器，在 applicationContext-mq-consumer.xml</code></pre><p><img src="https://i.imgur.com/BYc5Uql.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ActiveMQ-的作用分析&quot;&gt;&lt;a href=&quot;#ActiveMQ-的作用分析&quot; class=&quot;headerlink&quot; title=&quot;ActiveMQ 的作用分析&quot;&gt;&lt;/a&gt;ActiveMQ 的作用分析&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;ActiveMQ对列与web
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis缓存</title>
    <link href="http://htuotuo.top/2018/02/25/redis%E7%BC%93%E5%AD%98/"/>
    <id>http://htuotuo.top/2018/02/25/redis缓存/</id>
    <published>2018-02-25T05:31:00.876Z</published>
    <updated>2018-02-26T08:19:13.026Z</updated>
    
    <content type="html"><![CDATA[<pre><code>1、Redis服务器搭建2、向业务逻辑中添加缓存。3、使用redis做缓存4、缓存同步。5、Solr服务器安装</code></pre><h2 id="1-首页面的展示流程"><a href="#1-首页面的展示流程" class="headerlink" title="1.首页面的展示流程"></a>1.首页面的展示流程</h2><pre><code>首页是系统的门户，也就是系统的入口。所以首页的访问量是这个系统最大的。如果每次展示首页都从数据库中查询首页的内容信息，那么势必会对数据库造成很大的压力，所以需要使用缓存来减轻数据库压力。实现缓存的工具有很多，现在比较流行的是redis。</code></pre><h2 id="2-Redis的安装"><a href="#2-Redis的安装" class="headerlink" title="2.Redis的安装"></a>2.Redis的安装</h2><h3 id="1-Redis的安装"><a href="#1-Redis的安装" class="headerlink" title="1.Redis的安装"></a>1.Redis的安装</h3><pre><code>Redis是c语言开发的。安装redis需要c语言的编译环境。如果没有gcc需要在线安装。Yum install gcc-c++安装步骤：第一步：redis的源码包上传到linux系统。第二步：解压缩redis。第三步：编译。make 第四步：安装。make install PREFIX=/usr/local/redis</code></pre><h3 id="2-连接redis"><a href="#2-连接redis" class="headerlink" title="2.连接redis"></a>2.连接redis</h3><h4 id="redis的启动："><a href="#redis的启动：" class="headerlink" title="redis的启动："></a>redis的启动：</h4><pre><code>前端启动：[root@localhost bin]# ./redis-server 后台启动：把/root/redis-3.0.0/redis.conf复制到/usr/local/redis/bin目录下[root@localhost redis-3.0.0]# cp redis.conf /usr/local/redis/bin/修改配置文件：[root@localhost bin]# ./redis-server redis.conf查看redis进程：[root@localhost bin]# ps aux|grep redisroot      5190  0.1  0.3  33936  1712 ?        Ssl  18:23   0:00 ./redis-server *:6379    root      5196  0.0  0.1   4356   728 pts/0    S+   18:24   0:00 grep redis[root@localhost bin]# </code></pre><h4 id="Redis-cli"><a href="#Redis-cli" class="headerlink" title="Redis-cli"></a>Redis-cli</h4><pre><code>[root@localhost bin]# ./redis-cli 默认连接localhost运行在6379端口的redis服务。[root@localhost bin]# ./redis-cli -h 192.168.25.153 -p 6379-h：连接的服务器的地址-p：服务的端口号</code></pre><h2 id="3-Redis五种数据类型"><a href="#3-Redis五种数据类型" class="headerlink" title="3.Redis五种数据类型"></a>3.Redis五种数据类型</h2><pre><code>String：key-value（做缓存）Redis中所有数据都是key-value形式存储的,它都是字符串，命令不区分大小写，value    区分大小写，redis是单线程的，redis不适合保存内容大的数据（以k为单位）     get,set,incr 加一 （生成id）decr 减一Hash：key-fields-values（做缓存）相当于一个key对应一个map，map中也有key-value用hash对key进行分类 存值:hset key-filed-values  ,取值:hget key-filedhincrbodyList：有顺序可重复Set：无顺序，不能重复SortedSet（zset）：有顺序，不能重复</code></pre><h3 id="key命令"><a href="#key命令" class="headerlink" title="key命令"></a>key命令</h3><pre><code>设置key的过期时间Expire +key名字+ 时间（expire key second）Ttl key:查看key的有效期Persist key：清除key的过期时间。Key持久化</code></pre><h2 id="4-Redis的持久化"><a href="#4-Redis的持久化" class="headerlink" title="4.Redis的持久化"></a>4.Redis的持久化</h2><pre><code>Redis的所有数据都是保存在内存中Rdb （快照形式）：定期把内存中的数据保存在磁盘，内存中当前时刻（默认支持），丢失数据可能大aof形式：append only file。 把所有对数据库的操作（增删改操作的命令）保存到文件中。数据恢复时把所有的命令执行一遍即可</code></pre><h2 id="5-Redis集群的搭建"><a href="#5-Redis集群的搭建" class="headerlink" title="5.Redis集群的搭建"></a>5.Redis集群的搭建</h2><h3 id="redis-cluster架构图"><a href="#redis-cluster架构图" class="headerlink" title="redis-cluster架构图"></a>redis-cluster架构图</h3><p><img src="https://i.imgur.com/vUAokJA.png" alt=""></p><pre><code>架构细节:(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可(4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;valueRedis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点</code></pre><h3 id="Redis集群的搭建"><a href="#Redis集群的搭建" class="headerlink" title="Redis集群的搭建"></a>Redis集群的搭建</h3><pre><code>Redis集群中至少有3个节点，要保证集群的高可用，需要每个节点有一个备份机，redis集群至少要6台服务机</code></pre><h4 id="集群搭建环境"><a href="#集群搭建环境" class="headerlink" title="集群搭建环境"></a>集群搭建环境</h4><pre><code>1、使用ruby脚本搭建集群。需要ruby的运行环境。安装rubyyum install rubyyum install rubygems2、安装ruby脚本运行使用的包。[root@localhost ~]# gem install redis-3.0.0.gem Successfully installed redis-3.0.01 gem installedInstalling ri documentation for redis-3.0.0...Installing RDoc documentation for redis-3.0.0...[root@localhost ~]# [root@localhost ~]# cd redis-3.0.0/src[root@localhost src]# ll *.rb-rwxrwxr-x. 1 root root 48141 Apr  1  2015 redis-trib.rb5.2.2.搭建步骤需要6台redis服务器。搭建伪分布式。需要6个redis实例。需要运行在不同的端口7001-7006第一步：创建6个redis实例，每个实例运行在不同的端口。需要修改redis.conf配置文件。配置文件中还需要把cluster-enabled yes前的注释去掉。</code></pre><p><img src="https://i.imgur.com/R9unXjI.png" alt="">        </p><pre><code>第二步：启动每个redis实例。第三步：使用ruby脚本搭建集群。将*.rb 文件复制到redis-cluster 集群文件中./redis-trib.rb create --replicas 1 192.168.25.132:7001 192.168.25.132:7002 192.168.25.132:7003 192.168.25.132:7004 192.168.25.132:7005  192.168.25.132:7006如果是安装在同一个服务其中使用./redis-trib.rb create --replicas 1 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005  127.0.0.1:7006创建关闭集群的脚本：[root@localhost redis-cluster]# vim shutdow-all.shredis01/redis-cli -p 7001 shutdownredis01/redis-cli -p 7002 shutdownredis01/redis-cli -p 7003 shutdownredis01/redis-cli -p 7004 shutdownredis01/redis-cli -p 7005 shutdownredis01/redis-cli -p 7006 shutdown[root@localhost redis-cluster]# chmod u+x shutdow-all.sh [root@localhost redis-cluster]# ./redis-trib.rb create --replicas 1 192.168.25.153:7001 192.168.25.153:7002 192.168.25.153:7003 192.168.25.153:7004 192.168.25.153:7005  192.168.25.153:7006&gt;&gt;&gt; Creating clusterConnecting to node 192.168.25.153:7001: OKConnecting to node 192.168.25.153:7002: OKConnecting to node 192.168.25.153:7003: OKConnecting to node 192.168.25.153:7004: OKConnecting to node 192.168.25.153:7005: OKConnecting to node 192.168.25.153:7006: OK&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Using 3 masters:192.168.25.153:7001192.168.25.153:7002192.168.25.153:7003Adding replica 192.168.25.153:7004 to 192.168.25.153:7001Adding replica 192.168.25.153:7005 to 192.168.25.153:7002Adding replica 192.168.25.153:7006 to 192.168.25.153:7003M: 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3 192.168.25.153:7001   slots:0-5460 (5461 slots) masterM: 8cd93a9a943b4ef851af6a03edd699a6061ace01 192.168.25.153:7002   slots:5461-10922 (5462 slots) masterM: 2935007902d83f20b1253d7f43dae32aab9744e6 192.168.25.153:7003   slots:10923-16383 (5461 slots) masterS: 74f9d9706f848471583929fc8bbde3c8e99e211b 192.168.25.153:7004   replicates 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3S: 42cc9e25ebb19dda92591364c1df4b3a518b795b 192.168.25.153:7005   replicates 8cd93a9a943b4ef851af6a03edd699a6061ace01S: 8b1b11d509d29659c2831e7a9f6469c060dfcd39 192.168.25.153:7006   replicates 2935007902d83f20b1253d7f43dae32aab9744e6Can I set the above configuration? (type &apos;yes&apos; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join.....&gt;&gt;&gt; Performing Cluster Check (using node 192.168.25.153:7001)M: 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3 192.168.25.153:7001   slots:0-5460 (5461 slots) masterM: 8cd93a9a943b4ef851af6a03edd699a6061ace01 192.168.25.153:7002   slots:5461-10922 (5462 slots) masterM: 2935007902d83f20b1253d7f43dae32aab9744e6 192.168.25.153:7003   slots:10923-16383 (5461 slots) masterM: 74f9d9706f848471583929fc8bbde3c8e99e211b 192.168.25.153:7004   slots: (0 slots) master   replicates 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3M: 42cc9e25ebb19dda92591364c1df4b3a518b795b 192.168.25.153:7005   slots: (0 slots) master   replicates 8cd93a9a943b4ef851af6a03edd699a6061ace01M: 8b1b11d509d29659c2831e7a9f6469c060dfcd39 192.168.25.153:7006   slots: (0 slots) master   replicates 2935007902d83f20b1253d7f43dae32aab9744e6[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.[root@localhost redis-cluster]# </code></pre><h4 id="集群的使用方法"><a href="#集群的使用方法" class="headerlink" title="集群的使用方法"></a>集群的使用方法</h4><pre><code>Redis-cli连接集群。[root@localhost redis-cluster]# redis01/redis-cli -p 7002 -c-c：代表连接的是redis集群</code></pre><h2 id="6-Jedis"><a href="#6-Jedis" class="headerlink" title="6.Jedis"></a>6.Jedis</h2><pre><code>需要把jedis依赖的jar包添加到工程中。Maven工程中需要把jedis的坐标添加到依赖。推荐添加到服务层。Taotao-content-Service工程中。</code></pre><h3 id="6-1-连接单机版"><a href="#6-1-连接单机版" class="headerlink" title="6.1.连接单机版"></a>6.1.连接单机版</h3><pre><code>第一步：创建一个Jedis对象。需要指定服务端的ip及端口。第二步：使用Jedis对象操作数据库，每个redis命令对应一个方法。第三步：打印结果。第四步：关闭Jedis@Test    public void testJedis() throws Exception {        // 第一步：创建一个Jedis对象。需要指定服务端的ip及端口。        Jedis jedis = new Jedis(&quot;192.168.25.153&quot;, 6379);        // 第二步：使用Jedis对象操作数据库，每个redis命令对应一个方法。        String result = jedis.get(&quot;hello&quot;);        // 第三步：打印结果。        System.out.println(result);        // 第四步：关闭Jedis        jedis.close();    }</code></pre><h3 id="6-2-连接单机版使用连接池"><a href="#6-2-连接单机版使用连接池" class="headerlink" title="6.2.连接单机版使用连接池"></a>6.2.连接单机版使用连接池</h3><pre><code>第一步：创建一个JedisPool对象。需要指定服务端的ip及端口。第二步：从JedisPool中获得Jedis对象。第三步：使用Jedis操作redis服务器。第四步：操作完毕后关闭jedis对象，连接池回收资源。第五步：关闭JedisPool对象。@Test    public void testJedisPool() throws Exception {        // 第一步：创建一个JedisPool对象。需要指定服务端的ip及端口。        JedisPool jedisPool = new JedisPool(&quot;192.168.25.153&quot;, 6379);        // 第二步：从JedisPool中获得Jedis对象。        Jedis jedis = jedisPool.getResource();        // 第三步：使用Jedis操作redis服务器。        jedis.set(&quot;jedis&quot;, &quot;test&quot;);        String result = jedis.get(&quot;jedis&quot;);        System.out.println(result);        // 第四步：操作完毕后关闭jedis对象，连接池回收资源。        jedis.close();        // 第五步：关闭JedisPool对象。        jedisPool.close();    }</code></pre><h3 id="6-3-连接集群版"><a href="#6-3-连接集群版" class="headerlink" title="6.3.连接集群版"></a>6.3.连接集群版</h3><pre><code>第一步：使用JedisCluster对象。需要一个Set&lt;HostAndPort&gt;参数。Redis节点的列表。第二步：直接使用JedisCluster对象操作redis。在系统中单例存在。第三步：打印结果第四步：系统关闭前，关闭JedisCluster对象。@Test    public void testJedisCluster() throws Exception {        // 第一步：使用JedisCluster对象。需要一个Set&lt;HostAndPort&gt;参数。Redis节点的列表。        Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;();        nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7001));        nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7002));        nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7003));        nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7004));        nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7005));        nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7006));        JedisCluster jedisCluster = new JedisCluster(nodes);        // 第二步：直接使用JedisCluster对象操作redis。在系统中单例存在。        jedisCluster.set(&quot;hello&quot;, &quot;100&quot;);        String result = jedisCluster.get(&quot;hello&quot;);        // 第三步：打印结果        System.out.println(result);        // 第四步：系统关闭前，关闭JedisCluster对象。        jedisCluster.close();    }</code></pre><h2 id="7-向业务逻辑中添加缓存"><a href="#7-向业务逻辑中添加缓存" class="headerlink" title="7.向业务逻辑中添加缓存"></a>7.向业务逻辑中添加缓存</h2><h3 id="接口封装"><a href="#接口封装" class="headerlink" title="接口封装"></a>接口封装</h3><pre><code>常用的操作redis的方法提取出一个接口，分别对应单机版和集群版创建两个实现类。</code></pre><h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h4><pre><code>public interface JedisClient {    String set(String key, String value);    String get(String key);    Boolean exists(String key);    Long expire(String key, int seconds);    Long ttl(String key);    Long incr(String key);    Long hset(String key, String field, String value);    String hget(String key, String field);    Long hdel(String key, String... field);}</code></pre><h4 id="单机版实现类"><a href="#单机版实现类" class="headerlink" title="单机版实现类"></a>单机版实现类</h4><pre><code>public class JedisClientPool implements JedisClient {    @Autowired    private JedisPool jedisPool;    @Override    public String set(String key, String value) {        Jedis jedis = jedisPool.getResource();        String result = jedis.set(key, value);        jedis.close();        return result;    }    @Override    public String get(String key) {        Jedis jedis = jedisPool.getResource();        String result = jedis.get(key);        jedis.close();        return result;    }    @Override    public Boolean exists(String key) {        Jedis jedis = jedisPool.getResource();        Boolean result = jedis.exists(key);        jedis.close();        return result;    }    @Override    public Long expire(String key, int seconds) {        Jedis jedis = jedisPool.getResource();        Long result = jedis.expire(key, seconds);        jedis.close();        return result;    }    @Override    public Long ttl(String key) {        Jedis jedis = jedisPool.getResource();        Long result = jedis.ttl(key);        jedis.close();        return result;    }    @Override    public Long incr(String key) {        Jedis jedis = jedisPool.getResource();        Long result = jedis.incr(key);        jedis.close();        return result;    }    @Override    public Long hset(String key, String field, String value) {        Jedis jedis = jedisPool.getResource();        Long result = jedis.hset(key, field, value);        jedis.close();        return result;    }    @Override    public String hget(String key, String field) {        Jedis jedis = jedisPool.getResource();        String result = jedis.hget(key, field);        jedis.close();        return result;    }    @Override    public Long hdel(String key, String... field) {        Jedis jedis = jedisPool.getResource();        Long result = jedis.hdel(key, field);        jedis.close();        return result;    }}配置：applicationContext-redis.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans4.2.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context4.2.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx4.2.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util4.2.xsd&quot;&gt;    &lt;!-- 配置单机版的连接 --&gt;    &lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot;&gt;        &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;        &lt;constructor-arg name=&quot;port&quot; value=&quot;6379&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;bean id=&quot;jedisClientPool&quot; class=&quot;com.taotao.jedis.JedisClientPool&quot;/&gt;&lt;/beans&gt;</code></pre><h4 id="集群版实现类"><a href="#集群版实现类" class="headerlink" title="集群版实现类"></a>集群版实现类</h4><pre><code>package com.xxx.jedis;import org.springframework.beans.factory.annotation.Autowired;import redis.clients.jedis.JedisCluster;public class JedisClientCluster implements JedisClient {    @Autowired    private JedisCluster jedisCluster;    @Override    public String set(String key, String value) {        return jedisCluster.set(key, value);    }    @Override    public String get(String key) {        return jedisCluster.get(key);    }    @Override    public Boolean exists(String key) {        return jedisCluster.exists(key);    }    @Override    public Long expire(String key, int seconds) {        return jedisCluster.expire(key, seconds);    }    @Override    public Long ttl(String key) {        return jedisCluster.ttl(key);    }    @Override    public Long incr(String key) {        return jedisCluster.incr(key);    }    @Override    public Long hset(String key, String field, String value) {        return jedisCluster.hset(key, field, value);    }    @Override    public String hget(String key, String field) {        return jedisCluster.hget(key, field);    }    @Override    public Long hdel(String key, String... field) {        return jedisCluster.hdel(key, field);    }}Spring的配置：&lt;!-- 集群版的配置 --&gt;    &lt;bean id=&quot;jedisCluster&quot; class=&quot;redis.clients.jedis.JedisCluster&quot;&gt;        &lt;constructor-arg&gt;            &lt;set&gt;                &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;7001&quot;&gt;&lt;/constructor-arg&gt;                &lt;/bean&gt;                &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;7002&quot;&gt;&lt;/constructor-arg&gt;                &lt;/bean&gt;                &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;7003&quot;&gt;&lt;/constructor-arg&gt;                &lt;/bean&gt;                &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;7004&quot;&gt;&lt;/constructor-arg&gt;                &lt;/bean&gt;                &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;7005&quot;&gt;&lt;/constructor-arg&gt;                &lt;/bean&gt;                &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;7006&quot;&gt;&lt;/constructor-arg&gt;                &lt;/bean&gt;            &lt;/set&gt;        &lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;bean id=&quot;jedisClientCluster&quot; class=&quot;com.taotao.jedis.JedisClientCluster&quot;/&gt;注意：单机版和集群版不能共存，使用单机版时注释集群版的配置。使用集群版，把单机版注释。</code></pre><h3 id="封装代码测试"><a href="#封装代码测试" class="headerlink" title="封装代码测试"></a>封装代码测试</h3><pre><code>@Test    public void testJedisClient() throws Exception {        //初始化Spring容器        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext-*.xml&quot;);        //从容器中获得JedisClient对象        JedisClient jedisClient = applicationContext.getBean(JedisClient.class);        jedisClient.set(&quot;first&quot;, &quot;100&quot;);        String result = jedisClient.get(&quot;first&quot;);        System.out.println(result);    }</code></pre><h3 id="添加缓存"><a href="#添加缓存" class="headerlink" title="添加缓存"></a>添加缓存</h3><h4 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h4><pre><code>查询内容列表时添加缓存。1、查询数据库之前先查询缓存。2、查询到结果，直接响应结果。3、查询不到，缓存中没有需要查询数据库。4、把查询结果添加到缓存中。5、返回结果。向redis中添加缓存：Key：cidValue：内容列表。需要把java对象转换成json。使用hash对key进行归类。HASH_KEY:HASH            |--KEY:VALUE            |--KEY:VALUE            |--KEY:VALUE            |--KEY:VALUE注意：添加缓存不能影响正常业务逻辑。</code></pre><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>@Override    public List&lt;TbContent&gt; getContentList(long cid) {        //查询缓存        try {            String json = jedisClient.hget(CONTENT_KEY, cid + &quot;&quot;);            //判断json是否为空            if (StringUtils.isNotBlank(json)) {                //把json转换成list                List&lt;TbContent&gt; list = JsonUtils.jsonToList(json, TbContent.class);                return list;            }        } catch (Exception e) {            e.printStackTrace();        }        //根据cid查询内容列表        TbContentExample example = new TbContentExample();        //设置查询条件        Criteria criteria = example.createCriteria();        criteria.andCategoryIdEqualTo(cid);        //执行查询        List&lt;TbContent&gt; list = contentMapper.selectByExample(example);        //向缓存中添加数据        try {            jedisClient.hset(CONTENT_KEY, cid + &quot;&quot;, JsonUtils.objectToJson(list));        } catch (Exception e) {            e.printStackTrace();        }        return list;    }</code></pre><h3 id="缓存同步"><a href="#缓存同步" class="headerlink" title="缓存同步"></a>缓存同步</h3><pre><code>对内容信息做增删改操作后只需要把对应缓存删除即可。可以根据cid删除。@Override    public TaotaoResult addContent(TbContent content) {        //补全属性        content.setCreated(new Date());        content.setUpdated(new Date());        //插入数据        contentMapper.insert(content);        //缓存同步        jedisClient.hdel(CONTENT_KEY, content.getCategoryId().toString());        return TaotaoResult.ok();    }</code></pre><h2 id="8-搜索工程搭建"><a href="#8-搜索工程搭建" class="headerlink" title="8.搜索工程搭建"></a>8.搜索工程搭建</h2><pre><code>要实现搜索功能，需要搭建solr服务、搜索服务工程、搜索系统</code></pre><h3 id="Solr服务搭建"><a href="#Solr服务搭建" class="headerlink" title="Solr服务搭建"></a>Solr服务搭建</h3><h4 id="Solr的环境"><a href="#Solr的环境" class="headerlink" title="Solr的环境"></a>Solr的环境</h4><pre><code>Solr是java开发。需要安装jdk。安装环境Linux。需要安装Tomcat。</code></pre><h4 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><pre><code>第一步：把solr 的压缩包上传到Linux系统第二步：解压solr。第三步：安装Tomcat，解压缩即可。第四步：把solr部署到Tomcat下。第五步：解压缩war包。启动Tomcat解压。第六步：把/root/solr-4.10.3/example/lib/ext目录下的所有的jar包，添加到solr工程中。[root@localhost ext]# pwd/root/solr-4.10.3/example/lib/ext[root@localhost ext]# cp * /usr/local/solr/tomcat/webapps/solr/WEB-INF/lib/第七步：创建一个solrhome。/example/solr目录就是一个solrhome。复制此目录到/usr/local/solr/solrhome[root@localhost example]# pwd/root/solr-4.10.3/example[root@localhost example]# cp -r solr /usr/local/solr/solrhome[root@localhost example]# 第八步：关联solr及solrhome。需要修改solr工程的web.xml文件。第九步：启动Tomcathttp://192.168.25.154:8080/solr/和windows下的配置完全一样。</code></pre><h4 id="Solr的使用"><a href="#Solr的使用" class="headerlink" title="Solr的使用"></a>Solr的使用</h4><pre><code>添加文档必须有id域，其他域 必须在solr的schema.xml中定义。</code></pre><h3 id="配置业务域"><a href="#配置业务域" class="headerlink" title="配置业务域"></a>配置业务域</h3><pre><code>schema.xml中定义，这里定义的是自己需要进行索引的字段1、商品Id2、商品标题3、商品卖点4、商品价格5、商品图片6、分类名称7、商品描述创建对应的业务域。需要制定中文分析器。创建步骤：第一步：把中文分析器添加到工程中。1、把IKAnalyzer2012FF_u1.jar添加到solr工程的lib目录下2、把扩展词典、配置文件放到solr工程的WEB-INF/classes目录下。第二步：配置一个FieldType，制定使用IKAnalyzer修改schema.xml文件修改Solr的schema.xml文件，添加FieldType：&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;  &lt;analyzer class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;&lt;/fieldType&gt;第三步：配置业务域，type制定使用自定义的FieldType。设置业务系统Field&lt;field name=&quot;item_title&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_sell_point&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_price&quot;  type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_image&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_category_name&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_desc&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; /&gt;&lt;field name=&quot;item_keywords&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt;&lt;copyField source=&quot;item_title&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_sell_point&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_category_name&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_desc&quot; dest=&quot;item_keywords&quot;/&gt;第四步：重启tomcat</code></pre><h3 id="搜索服务工程搭建"><a href="#搜索服务工程搭建" class="headerlink" title="搜索服务工程搭建"></a>搜索服务工程搭建</h3><pre><code>可以参考taotao-manager创建。项目名-search（聚合工程pom）|--项目名-search-interface（jar）|--项目名-search-Service（war）</code></pre><h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><pre><code>怎么将二维表的转为redis的String 类型数据使用：的格式进行转换：表名：主键id：字段名：字段内容    </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;1、Redis服务器搭建
2、向业务逻辑中添加缓存。
3、使用redis做缓存
4、缓存同步。
5、Solr服务器安装
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-首页面的展示流程&quot;&gt;&lt;a href=&quot;#1-首页面的展示流程&quot; class=&quot;headerl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webservice的Restful风格</title>
    <link href="http://htuotuo.top/2018/02/24/webservice%E7%9A%84Restful%E9%A3%8E%E6%A0%BC/"/>
    <id>http://htuotuo.top/2018/02/24/webservice的Restful风格/</id>
    <published>2018-02-24T12:54:44.032Z</published>
    <updated>2018-02-25T05:28:01.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的xml（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。用于多系统之间的交互</p><h2 id="什么是Web-Service"><a href="#什么是Web-Service" class="headerlink" title="什么是Web Service"></a>什么是Web Service</h2><pre><code>Web service 就是一个应用程序，它向外界暴露出一个能够通过Web进行调用的APIWeb services是建立可互操作的分布式应用程序的新平台Web service平台是一套标准，它定义了应用程序如何在Web上实现互操作性。你可以用任何你喜欢的语言，在任何你喜欢的平台上写Web service ，只要我们可以通过Web service标准对这些服务进行查询和访问。</code></pre><h2 id="JAX-WS-独立服务使用-了解"><a href="#JAX-WS-独立服务使用-了解" class="headerlink" title="JAX-WS 独立服务使用(了解)"></a>JAX-WS 独立服务使用(了解)</h2><h2 id="JAX-RS-独立服务使用-了解"><a href="#JAX-RS-独立服务使用-了解" class="headerlink" title="JAX-RS 独立服务使用(了解)"></a>JAX-RS 独立服务使用(了解)</h2><pre><code>restful风格好处：基于这种风格架构，软件编写可以更简洁基于 HTTP 协议， 支持多种消息格式，比如 XML 、 JSON更易于实现缓存机制（第一次访问资源 缓存，第二次访问资源，返回 304 客户端调用本地）</code></pre><p><img src="https://i.imgur.com/vNjcvZk.png" alt=""></p><pre><code>以上定义的只是一种风格不是一种固定格式POST 请求方式访问 保存操作PUT 请求方式访问 修改操作GET 请求方式访问 查询操作DELETE 请求方式访问 删除操作</code></pre><h3 id="JAX-RS的使用步骤："><a href="#JAX-RS的使用步骤：" class="headerlink" title="JAX-RS的使用步骤："></a>JAX-RS的使用步骤：</h3><h4 id="1-基于-maven-导入坐标"><a href="#1-基于-maven-导入坐标" class="headerlink" title="1.基于 maven 导入坐标"></a>1.基于 maven 导入坐标</h4><h4 id="2、-导入实体类"><a href="#2、-导入实体类" class="headerlink" title="2、 导入实体类"></a>2、 导入实体类</h4><p><img src="https://i.imgur.com/8v8wmLD.png" alt=""></p><pre><code>在实体类上一定要加入@XmlRootElement(name=&quot;User&quot;);@XmlRootElement 指定序列化（转换 XML、 JSON） 对象名字</code></pre><p><img src="https://i.imgur.com/4bAjpjN.png" alt=""></p><pre><code>如果没加@XmlRootElement(name=&quot;User&quot;)注解就会出现以下错误：</code></pre><p><img src="https://i.imgur.com/WcajaeP.png" alt=""></p><pre><code>如果该类使用了泛型还需添加另一个注解@XmlSeeAlso({ xxx.class })中括号中添加为泛型的类型的类</code></pre><h4 id="3、-编写业务类"><a href="#3、-编写业务类" class="headerlink" title="3、 编写业务类"></a>3、 编写业务类</h4><p><img src="https://i.imgur.com/KDUQtQi.png" alt=""></p><pre><code>第一种 @Path 服务访问资源路径如果访问 saveUser 方法 /userService/user第二种 @Produces 生成（方法返回值） @Consumes 消费 （方法参数）@Consumes 指定能够处理客户端传递过来数据格式@Produces 指定能否生成哪种格式数据返回给客户端第三种 @GET 查询 @PUT 修改 @POST 增加 @DELETE 删除</code></pre><h4 id="4、-发布服务（单独发布）"><a href="#4、-发布服务（单独发布）" class="headerlink" title="4、 发布服务（单独发布）"></a>4、 发布服务（单独发布）</h4><p><img src="https://i.imgur.com/gLjghe3.png" alt=""></p><h4 id="5、-客户端程序的编写"><a href="#5、-客户端程序的编写" class="headerlink" title="5、 客户端程序的编写"></a>5、 客户端程序的编写</h4><pre><code>有两种做法1） 使用 http client 工具 ，需要自己对 HTTP 协议内容进行定制和解析2） WebClient 工具类使用 （CXF 自带）</code></pre><p><img src="https://i.imgur.com/obDga9R.png" alt=""></p><pre><code>JAX-RS 如何传输 JSON 格式的数据 ？如果指定客户端要获取 json 内容错误： Caused by: javax.ws.rs.ProcessingException: No message body writer has been foundfor class cn.itcast.cxf.domain.User, ContentType: application/json解决： 在项目引入 json 转换器</code></pre><p><img src="https://i.imgur.com/2xeUyDM.png" alt=""></p><h2 id="JAX-RS-和-Spring-整合开发使用（重点）"><a href="#JAX-RS-和-Spring-整合开发使用（重点）" class="headerlink" title="JAX-RS 和 Spring 整合开发使用（重点）"></a>JAX-RS 和 Spring 整合开发使用（重点）</h2><h3 id="1-maven坐标引入"><a href="#1-maven坐标引入" class="headerlink" title="1.maven坐标引入"></a>1.maven坐标引入</h3><p><img src="https://i.imgur.com/cEJPXpb.png" alt=""></p><p><img src="https://i.imgur.com/MiWJvkz.png" alt=""></p><pre><code>导入 web.xml，在web.xml中需要添加一个webservice配置</code></pre><p><img src="https://i.imgur.com/2ISJ2XP.png" alt=""></p><h3 id="2、-导入实体类和-Service"><a href="#2、-导入实体类和-Service" class="headerlink" title="2、 导入实体类和 Service"></a>2、 导入实体类和 Service</h3><h3 id="3、-在-spring-配置发布-rs-服务"><a href="#3、-在-spring-配置发布-rs-服务" class="headerlink" title="3、 在 spring 配置发布 rs 服务"></a>3、 在 spring 配置发布 rs 服务</h3><pre><code>引入名称空间 xmlns:jaxrs=&quot;http://cxf.apache.org/jaxrs&quot;http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/jaxrs.xsd最终访问资源服务路径服务器根目录地址 + web.xml 配置 + applicationContext.xml address 配置 + 类@Path +方法 @Path</code></pre><p><img src="https://i.imgur.com/P3AgeTW.png" alt=""></p><pre><code>applicationContext-webservice.xml服务端配置</code></pre><p><img src="https://i.imgur.com/SkQOoW1.png" alt=""></p><h3 id="4、-编写客户端代码-类似独立服务客户端代码"><a href="#4、-编写客户端代码-类似独立服务客户端代码" class="headerlink" title="4、 编写客户端代码 类似独立服务客户端代码"></a>4、 编写客户端代码 类似独立服务客户端代码</h3><pre><code>WebClient 工具实现，客户端不需要进行配置直接使用webclient。create方法进行调用，访问路径参照：服务器根目录地址 + web.xml 配置 + applicationContext.xml address 配置 + 类@Path +方法 @Path// 使用webClient调用 webService接口Collection&lt;? extends Customer&gt; collection = WebClient        .create(&quot;http://localhost:9002/crm_management/services/userservice/xxx&quot;)        .accept(MediaType.APPLICATION_JSON)        .getCollection(Customer.class);如果有返回值，返回的是结果集就使用getConllection获取，单个结果就直接使用getaccept为接收返回值</code></pre><p>注意：在webservice中服务方法参数有两个注解：</p><p>@pathParam 如果在方法参数中使用该配置，在客户端访问路径/后面直接拼接参数</p><p><img src="https://i.imgur.com/fb7DKES.png" alt=""></p><p>@queryparam 如果在方法参数中使用该配置，在客户端访问路径必须使用？&amp;的方式进行参数的拼接</p><p><img src="https://i.imgur.com/ZkylBdF.png" alt=""></p><h2 id="在用于分布式系统间的通讯，还有一个dubbo（个人觉得dubbo更好使用）"><a href="#在用于分布式系统间的通讯，还有一个dubbo（个人觉得dubbo更好使用）" class="headerlink" title="在用于分布式系统间的通讯，还有一个dubbo（个人觉得dubbo更好使用）"></a>在用于分布式系统间的通讯，还有一个dubbo（个人觉得dubbo更好使用）</h2><h3 id="1-什么是dubbo"><a href="#1-什么是dubbo" class="headerlink" title="1.什么是dubbo"></a>1.什么是dubbo</h3><pre><code>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</code></pre><ul><li><p>单一应用架构 </p><ul><li>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。<br>此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</li></ul></li><li><p>垂直应用架构 </p><ul><li>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。<br>此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</li></ul></li><li><p>分布式服务架构 </p><ul><li>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</li></ul></li><li><p>流动计算架构 </p><ul><li>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。<br><strong>Dubbo就是资源调度和治理中心的管理工具。</strong></li></ul></li></ul><h3 id="2-Dubbo的架构"><a href="#2-Dubbo的架构" class="headerlink" title="2.Dubbo的架构"></a>2.Dubbo的架构</h3><p><img src="https://i.imgur.com/Qr5lJBC.png" alt=""></p><ul><li><p>节点角色说明：</p><ol><li>Provider: 暴露服务的服务提供方。</li><li>Consumer: 调用远程服务的服务消费方。</li><li>Registry: 服务注册与发现的注册中心。</li><li>Monitor: 统计服务的调用次调和调用时间的监控中心。</li><li>Container: 服务运行容器。</li></ol></li><li><p>调用关系说明：</p><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol></li></ul><h3 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3.使用方法"></a>3.使用方法</h3><pre><code>1.Spring配置Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。单一工程中spring的配置&lt;bean id=&quot;xxxService&quot; class=&quot;com.xxx.XxxServiceImpl&quot; /&gt;&lt;bean id=&quot;xxxAction&quot; class=&quot;com.xxx.XxxAction&quot;&gt;    &lt;property name=&quot;xxxService&quot; ref=&quot;xxxService&quot; /&gt;&lt;/bean&gt;远程服务：在本地服务的基础上，只需做简单配置，即可完成远程化：将上面的local.xml配置拆分成两份，将服务定义部分放在服务提供方remote-provider.xml，将服务引用部分放在服务消费方remote-consumer.xml。并在提供方增加暴露服务配置&lt;dubbo:service&gt;，在消费方增加引用服务配置&lt;dubbo:reference&gt;。发布服务：&lt;!-- 和本地服务一样实现远程服务 --&gt;&lt;bean id=&quot;xxxService&quot; class=&quot;com.xxx.XxxServiceImpl&quot; /&gt;&lt;!-- 增加暴露远程服务配置 --&gt;&lt;dubbo:service interface=&quot;com.xxx.XxxService&quot; ref=&quot;xxxService&quot; /&gt;调用服务：&lt;!-- 增加引用远程服务配置 --&gt;&lt;dubbo:reference id=&quot;xxxService&quot; interface=&quot;com.xxx.XxxService&quot; /&gt;&lt;!-- 和本地服务一样使用远程服务 --&gt;&lt;bean id=&quot;xxxAction&quot; class=&quot;com.xxx.XxxAction&quot;&gt;    &lt;property name=&quot;xxxService&quot; ref=&quot;xxxService&quot; /&gt;&lt;/bean&gt;</code></pre><p>   2.注册中心</p><pre><code>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。使用dubbo-2.3.3以上版本，建议使用zookeeper注册中心。Zookeeper是Apacahe Hadoop的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用Zookeeper的安装：第一步：安装jdk第二步：解压缩zookeeper压缩包第三步：将conf文件夹下zoo_sample.cfg复制一份，改名为zoo.cfg第四步：修改配置dataDir属性，指定一个真实目录第五步：启动zookeeper：bin/zkServer.sh start关闭zookeeper：bin/zkServer.sh stop查看zookeeper状态：bin/zkServer.sh status</code></pre><h3 id="4-框架整合"><a href="#4-框架整合" class="headerlink" title="4.框架整合"></a>4.框架整合</h3><h4 id="添加dubbo的依赖"><a href="#添加dubbo的依赖" class="headerlink" title="添加dubbo的依赖"></a>添加dubbo的依赖</h4><pre><code>加入dubbo相关的jar包。服务层、表现层都添加。&lt;!-- dubbo相关 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;dubbo&lt;/artifactId&gt;        &lt;!-- 排除依赖 --&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring&lt;/artifactId&gt;            &lt;/exclusion&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.jboss.netty&lt;/groupId&gt;                &lt;artifactId&gt;netty&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;        &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;        &lt;artifactId&gt;zkclient&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><h4 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h4><pre><code>1、Dao层：mybatis整合spring，通过spring管理SqlSessionFactory、mapper代理对象。需要mybatis和spring的整合包。整合内容    对应工程Pojo   项目名称Mapper映射文件    项目名称Mapper接口    项目名称sqlmapConfig.xml    项目名称applicationContext-dao.xml    项目名称2、Service层：所有的service实现类都放到spring容器中管理。由spring创建数据库连接池，并有spring管理实务。发布dubbo服务整合内容    对应工程Service接口    项目名称service实现类    项目名称applicationContext-service.xml    项目名称applicationContext-trans.xml      项目名称（事务配置文件）3、表现层：Springmvc框架，由springmvc管理controller。引用dubbo服务整合内容    对应工程Springmvc.xml（扫描controller、引用dubbo服务）    项目名称Controller    项目名称</code></pre><h4 id="Dao整合"><a href="#Dao整合" class="headerlink" title="Dao整合"></a>Dao整合</h4><pre><code>创建SqlMapConfig.xml配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt;4.3.2.Spring整合mybatis创建applicationContext-dao.xml&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd&quot;&gt;    &lt;!-- 数据库连接池 --&gt;    &lt;!-- 加载配置文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:properties/*.properties&quot; /&gt;    &lt;!-- 数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;        destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;        &lt;property name=&quot;minIdle&quot; value=&quot;5&quot; /&gt;    &lt;/bean&gt;    &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;        &lt;!-- 加载mybatis的全局配置文件 --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt;    &lt;/bean&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.taotao.mapper&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;db.propertiesjdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/taotao?characterEncoding=utf-8jdbc.username=rootjdbc.password=root备注：Druid是目前最好的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss DataSource。Druid已经在阿里巴巴部署了超过600个应用，经过多年多生产环境大规模部署的严苛考验。</code></pre><h4 id="Service整合"><a href="#Service整合" class="headerlink" title="Service整合"></a>Service整合</h4><pre><code>管理Service&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd    http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.taotao.service&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 使用dubbo发布服务 --&gt;    &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;    &lt;dubbo:application name=&quot;taotao-manager&quot; /&gt;    &lt;dubbo:registry protocol=&quot;zookeeper&quot;        address=&quot;192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183&quot; /&gt;    &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;    &lt;!-- 声明需要暴露的服务接口 --&gt;    &lt;dubbo:service interface=&quot;com.taotao.service.ItemService&quot; ref=&quot;itemServiceImpl&quot; /&gt;&lt;/beans&gt;</code></pre><h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><pre><code>创建applicationContext-trans.xml&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd&quot;&gt;    &lt;!-- 事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot;        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;!-- 数据源 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;    &lt;!-- 通知 --&gt;    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;!-- 传播行为 --&gt;            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;create*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;            &lt;tx:method name=&quot;select*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;            &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!-- 切面 --&gt;    &lt;aop:config&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot;            pointcut=&quot;execution(* com.taotao.service.*.*(..))&quot; /&gt;    &lt;/aop:config&gt;&lt;/beans&gt;Web.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;    &lt;display-name&gt;taotao-manager&lt;/display-name&gt;    &lt;!-- 加载spring容器 --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:spring/applicationContext*.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;&lt;/web-app&gt;</code></pre><h4 id="表现层整合"><a href="#表现层整合" class="headerlink" title="表现层整合"></a>表现层整合</h4><pre><code>Springmvc.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;     xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.taotao.controller&quot; /&gt;    &lt;mvc:annotation-driven /&gt;    &lt;bean        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;    &lt;/bean&gt;    &lt;!-- 引用dubbo服务 --&gt;    &lt;dubbo:application name=&quot;taotao-manager-web&quot;/&gt;    &lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183&quot;/&gt;        &lt;dubbo:reference interface=&quot;com.taotao.service.ItemService&quot; id=&quot;itemService&quot; /&gt;&lt;/beans&gt;web.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;    &lt;display-name&gt;taotao-manager-web&lt;/display-name&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;login.html&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;!-- 解决post乱码 --&gt;    &lt;filter&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;utf-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;!-- springmvc的前端控制器 --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;taotao-manager&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!-- contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+&quot;-servlet.xml&quot; --&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;taotao-manager&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h2&gt;&lt;p&gt;web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的xml（标准通用标记语言下的一个子集）
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis命令</title>
    <link href="http://htuotuo.top/2018/02/24/redis%E5%91%BD%E4%BB%A4/"/>
    <id>http://htuotuo.top/2018/02/24/redis命令/</id>
    <published>2018-02-24T12:08:51.961Z</published>
    <updated>2018-02-24T12:32:13.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Redis-hash-常用命令"><a href="#1-Redis-hash-常用命令" class="headerlink" title="1.Redis hash 常用命令"></a>1.Redis hash 常用命令</h2><pre><code>1、HDEL key field1 [field2] 删除一个或多个哈希表字段`2、HEXISTS key field    查看哈希表 key 中，指定的字段是否存在。3、HGET key field    获取存储在哈希表中指定字段的值。`4、HGETALL key    获取在哈希表中指定 key 的所有字段和值5、HKEYS key    获取所有哈希表中的字段6、HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment 。7、HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。8、HLEN key    获取哈希表中字段的数量9、HMGET key field1 [field2]    获取所有给定字段的值10、HMSET key field1 value1 [field2 value2 ]    同时将多个 field-value (域-值)对设置到哈希表 key 中。11、HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。12、HSETNX key field value    只有在字段 field 不存在时，设置哈希表字段的值。</code></pre><h2 id="2-Redis-String-常用命令"><a href="#2-Redis-String-常用命令" class="headerlink" title="2.Redis String 常用命令"></a>2.Redis String 常用命令</h2><pre><code>1、SET key value  设置指定 key 的值2、GET key  获取指定 key 的值。3、GETRANGE key start end  返回 key 中字符串值的子字符4、GETSET key value  将给定 key 的值设为 value ，并返回 key 的旧值(old value)。5、GETBIT key offset 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。6、MGET key1 [key2..]  获取所有(一个或多个)给定 key 的值。7、SETBIT key offset value  对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。8、SETEX key seconds value  将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。9、SETNX key value  只有在 key 不存在时设置 key 的值。10、SETRANGE key offset value 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。11、STRLEN key  返回 key 所储存的字符串值的长度。12、MSET key value [key value ...]  同时设置一个或多个 key-value 对。13、MSETNX key value [key value ...]同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。14、PSETEX key milliseconds value这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。15、INCR key 将 key 中储存的数字值增一。16、INCRBY key increment 将 key 所储存的值加上给定的增量值（increment） 。17、INCRBYFLOAT key increment  将 key 所储存的值加上给定的浮点增量值（increment） 。18、DECR key 将 key 中储存的数字值减一。19、DECRBY key decrement key 所储存的值减去给定的减量值（decrement） 。20、APPEND key value如果 key 已经存在并且是一个字符串， APPEND 命令将 指定value 追加到改 key 原来的值（value）的末尾。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Redis-hash-常用命令&quot;&gt;&lt;a href=&quot;#1-Redis-hash-常用命令&quot; class=&quot;headerlink&quot; title=&quot;1.Redis hash 常用命令&quot;&gt;&lt;/a&gt;1.Redis hash 常用命令&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1、
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux常见命令</title>
    <link href="http://htuotuo.top/2018/02/24/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://htuotuo.top/2018/02/24/linux常见命令/</id>
    <published>2018-02-24T12:07:43.734Z</published>
    <updated>2018-02-24T12:32:03.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手动配置IP地址"><a href="#手动配置IP地址" class="headerlink" title="手动配置IP地址"></a>手动配置IP地址</h2><h3 id="自动获取IP地址"><a href="#自动获取IP地址" class="headerlink" title="自动获取IP地址"></a>自动获取IP地址</h3><pre><code>虚拟机使用桥接模式，相当于连接到物理机的网络里，物理机网络有DHCP服务器自动分配IP地址。#dhclient 自动获取ip地址命令#ifconfig 查询系统里网卡信息，ip地址、MAC地址分配到ip地址后，用物理机进行ping ip地址，检测是否ping通。</code></pre><h3 id="手动设置ip地址"><a href="#手动设置ip地址" class="headerlink" title="手动设置ip地址"></a>手动设置ip地址</h3><pre><code>如果虚拟机不能自动获取IP，只能手动配置，配置方法如下：输入命令#vi /etc/sysconfig/network-scripts/ifcfg-eth0编辑网卡的配置文件输入上述命令后回车，打开配置文件，使用方向键移动光标到最后一行，按字母键“O”，进入编辑模式，输入以下内容：IPADDR=192.168.25.10NETMASK=255.255.255.0GATEWAY=192.168.25.1另外光标移动到”ONBOOT=no”这一行，更改为ONBOOT=yes“BOOTPROTO=dhcp”，更改为BOOTPROTO=none完成后，按一下键盘左上角ESC键，输入:wq 在屏幕的左下方可以看到，输入回车保存配置文件。之后需要重启一下网络服务，命令为#service network restart网络重启后，eth0的ip就生效了，使用命令#ifconfigeth0 查看接下来检测配置的IP是否可以ping通，在物理机使用快捷键WINDOWS+R 打开运行框，输入命令cmd，输入ping 192.168.4.10 进行检测，ping通说明IP配置正确。备注：我所在的物理机网段为192.168.4.0 网段。大家做实验的时候根据自己的环境进行设定，保持虚拟机和物理机在同一网段即可。</code></pre><h3 id="使用NAT模式"><a href="#使用NAT模式" class="headerlink" title="使用NAT模式"></a>使用NAT模式</h3><pre><code>虚拟机网络连接使用NAT模式，物理机网络连接使用Vmnet8。虚拟机设置里面——网络适配器，网络连接选择NAT模式。虚拟机菜单栏—编辑—虚拟网络编辑器，选择Vmnet8 NAT模式，1．在最下面子网设置ip为192.168.20.0 子网掩码255.255.255.02．NAT设置里面网关IP为192.168.20.23．使用本地DHCP服务将IP地址分配给虚拟机不勾选设置完成后点击应用退出。CentOS 6.5 配置IP地址的三种方法物理机网络连接VMNet8 手动设置ip地址 192.168.20.1 子网掩码255.255.255.0网关和DNS地址为192.168.20.2（即虚拟机NAT的网关地址）编辑linux网卡eth0的配置文件#vi /etc/sysconfig/network-scripts/ifcfg-eth0输入上述命令后回车，打开配置文件，使用方向键移动光标到最后一行，按字母键“O”，进入编辑模式，输入以下内容：IPADDR=192.168.25.3NETMASK=255.255.255.0GATEWAY=192.168.25.2另外光标移动到”ONBOOT=no”这一行，更改为ONBOOT=yes“BOOTPROTO=dhcp”，更改为BOOTPROTO=none完成后，按一下键盘左上角ESC键，输入:wq 在屏幕的左下方可以看到，输入回车保存配置文件。设置DNS地址,运行命令#vi /etc/resolv.conf光标移动到空行，按“O”键，输入 nameserver 192.168.25.2 退出按ESC键，输入:wq 回车保存配置文件。重启网络服务#service network restart重启之后#ifconfig</code></pre><h2 id="unzip命令安装"><a href="#unzip命令安装" class="headerlink" title="unzip命令安装"></a>unzip命令安装</h2><pre><code>yum install zip unzip</code></pre><h2 id="解压缩和压缩"><a href="#解压缩和压缩" class="headerlink" title="解压缩和压缩"></a>解压缩和压缩</h2><pre><code>tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。常用参数：-c：创建一个新tar文件-v：显示运行过程的信息-f：指定文件名-z：调用gzip压缩命令进行压缩-t：查看压缩文件的内容-x：解开tar文件</code></pre><h2 id="jdk配置"><a href="#jdk配置" class="headerlink" title="jdk配置"></a>jdk配置</h2><pre><code>//打开/etc/profile文件# vim /etc/profile在文件末尾插入如下内容export JAVA_HOME=/home/soft/jdk1.8.0_111 export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH最后执行 source /etc/profile</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code>不询问递归删除（慎用）rm -rf  a  ?  不询问递归删除rm -rf *   ?   删除所有文件</code></pre><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><pre><code>管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。示例ls --help | more  分页查询帮助信息ps –ef | grep java  查询名称中包含java的进程ifconfig | morecat index.html | moreps –ef | grep aio</code></pre><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><pre><code>entOS 6.5关闭防火墙步骤临时关闭命令：  service iptables stop 永久关闭防火墙：chkconfig iptables off开启改为 on两个命令同时运行，运行完成后查看防火墙关闭状态 service iptables status</code></pre><h2 id="出现centos-yum报错Loaded-plugins-fastestmirror"><a href="#出现centos-yum报错Loaded-plugins-fastestmirror" class="headerlink" title="出现centos yum报错Loaded plugins: fastestmirror"></a>出现centos yum报错Loaded plugins: fastestmirror</h2><pre><code>vi /etc/yum/pluginconf.d/fastestmirror.conf enabled = 0vi /etc/yum.confplugins=0yum clean dbcache</code></pre><h2 id="在使用yum时如果出现：Cannot-find-a-valid-baseurl-for-repo-base-7-x86-64"><a href="#在使用yum时如果出现：Cannot-find-a-valid-baseurl-for-repo-base-7-x86-64" class="headerlink" title="在使用yum时如果出现：Cannot find a valid baseurl for repo: base/7/x86_64"></a>在使用yum时如果出现：Cannot find a valid baseurl for repo: base/7/x86_64</h2><pre><code>这种情况通常是，是因为没有配置DNS服务器。解决方法：用VI编辑resolv.conf文件命令vi /etc/resolv.conf添加：nameserver 114.114.114.114    国内的wq保存退出即可</code></pre><h2 id="授予权限-c-权限不够"><a href="#授予权限-c-权限不够" class="headerlink" title="授予权限  ///**/c: 权限不够"></a>授予权限  /<strong>/</strong>/**/c: 权限不够</h2><pre><code>chmod +x /**/**/**/c</code></pre><h2 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h2><pre><code>Redis是c语言开发的。安装redis需要c语言的编译环境。如果没有gcc需要在线安装。先查询系统中是否有gcc命令，如果出现下面提示，则表示你的系统中已经安装好了gcc命令    [root@admin ~]# gccgcc: 没有输入文件[root@admin ~]# makemake: *** 没有指明目标并且找不到 makefile。 停止。安装：在线，必须配置的ip地址与虚拟机网关在统一个网段![](https://i.imgur.com/2aWQZVJ.png)yum install gcc-c++安装步骤：第一步：redis的源码包上传到linux系统。第二步：解压缩redis。第三步：编译。make 第四步：安装。make install PREFIX=/usr/local/redis</code></pre><h3 id="redis的启动："><a href="#redis的启动：" class="headerlink" title="redis的启动："></a>redis的启动：</h3><pre><code>前端启动：[root@localhost bin]# ./redis-server 后台启动：把/root/redis-3.0.0/redis.conf复制到/usr/local/redis/bin目录下[root@localhost redis-3.0.0]# cp redis.conf /usr/local/redis/bin/修改配置文件：[root@localhost bin]# ./redis-server redis.conf查看redis进程：[root@localhost bin]# ps aux|grep redisroot      5190  0.1  0.3  33936  1712 ?        Ssl  18:23   0:00 ./redis-server *:6379    root      5196  0.0  0.1   4356   728 pts/0    S+   18:24   0:00 grep redis[root@localhost bin]# </code></pre><h2 id="在使用yum命令进行安装时可能出现："><a href="#在使用yum命令进行安装时可能出现：" class="headerlink" title="在使用yum命令进行安装时可能出现："></a>在使用yum命令进行安装时可能出现：</h2><pre><code>Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=6&amp;arch=x86_64&amp;repo=os error was14: PYCURL ERROR 6 - &quot;Couldn&apos;t resolve host &apos;mirrorlist.centos.org&apos;&quot;Error: Cannot find a valid baseurl for repo: base错误，如果出现此错误：解决：解决方法：编辑vi resolv.conf文件，添加：nameserver 8.8.8.8 </code></pre><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><pre><code>cp(选项)(参数)选项-a：此参数的效果和同时指定&quot;-dpR&quot;参数相同；-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；-f：强行复制文件或目录，不论目标文件或目录是否已存在；-i：覆盖既有文件之前先询问用户；-l：对源文件建立硬连接，而非复制文件；-p：保留源文件或目录的属性；-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；-s：对源文件建立符号连接，而非复制文件；-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；-b：覆盖已存在的文件目标前将目标文件备份；-v：详细显示命令执行的操作。</code></pre><h2 id="文本编辑命令"><a href="#文本编辑命令" class="headerlink" title="文本编辑命令"></a>文本编辑命令</h2><h3 id="进入vi-vim的命令"><a href="#进入vi-vim的命令" class="headerlink" title="进入vi/vim的命令"></a>进入vi/vim的命令</h3><pre><code>vi/vim filename :打开或新建文件，并将光标置于第一行首vi/vim +n filename ：打开文件，并将光标置于第n行首vi/vim + filename ：打开文件，并将光标置于最后一行首vi/vim +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处vi/vim -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filenamevi/vim filename….filename ：打开多个文件，依次进行编辑</code></pre><h3 id="屏幕翻滚类命令"><a href="#屏幕翻滚类命令" class="headerlink" title="屏幕翻滚类命令"></a>屏幕翻滚类命令</h3><pre><code>Ctrl+u：向文件首翻半屏Ctrl+d：向文件尾翻半屏Ctrl+f：向文件尾翻一屏Ctrl＋b；向文件首翻一屏nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。</code></pre><h3 id="插入文本类命令"><a href="#插入文本类命令" class="headerlink" title="插入文本类命令"></a>插入文本类命令</h3><pre><code>i ：在光标前I ：在当前行首a：光标后A：在当前行尾o：在当前行之下新开一行O：在当前行之上新开一行r：替换当前字符R：替换当前字符及其后的字符，直至按ESC键s：从当前光标位置处开始，以输入的文本替代指定数目的字符S：删除指定数目的行，并以所输入文本代替之ncw或nCW：修改指定数目的字nCC：修改指定数目的行</code></pre><h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><pre><code>ndw或ndW：删除光标处开始及其后的n-1个字do：删至行首d$：删至行尾ndd：删除当前行及其后n-1行x或X：删除一个字符，x删除光标后的，而X删除光标前的Ctrl+u：删除输入方式下所输入的文本</code></pre><h3 id="搜索及替换命令"><a href="#搜索及替换命令" class="headerlink" title="搜索及替换命令"></a>搜索及替换命令</h3><pre><code>/pattern：从光标开始处向文件尾搜索pattern?pattern：从光标开始处向文件首搜索patternn：在同一方向重复上一次搜索命令N：在反方向上重复上一次搜索命令：s/p1/p2/g：将当前行中所有p1均用p2替代：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代：g/p1/s//p2/g：将文件中所有p1均用p2替换</code></pre><h3 id="选项设置"><a href="#选项设置" class="headerlink" title="选项设置"></a>选项设置</h3><pre><code>all：列出所有选项设置情况term：设置终端类型ignorance：在搜索中忽略大小写list：显示制表位(Ctrl+I)和行尾标志（$)number：显示行号report：显示由面向行的命令修改过的数目terse：显示简短的警告信息warn：在转到别的文件时若没保存当前文件则显示NO write信息nomagic：允许在搜索模式中，使用前面不带“\”的特殊字符nowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始mesg：允许vi显示其他用户用write写到自己终端上的信息</code></pre><h3 id="末行模式命令"><a href="#末行模式命令" class="headerlink" title="末行模式命令"></a>末行模式命令</h3><pre><code>：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下：n1,n2 d ：将n1行到n2行之间的内容删除：w ：保存当前文件：e filename：打开文件filename进行编辑：x：保存当前文件并退出：q：退出vi：q!：不保存文件并退出vi：!command：执行shell命令command：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入：r!command：将命令command的输出结果放到当前行 </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;手动配置IP地址&quot;&gt;&lt;a href=&quot;#手动配置IP地址&quot; class=&quot;headerlink&quot; title=&quot;手动配置IP地址&quot;&gt;&lt;/a&gt;手动配置IP地址&lt;/h2&gt;&lt;h3 id=&quot;自动获取IP地址&quot;&gt;&lt;a href=&quot;#自动获取IP地址&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Excel解析和生成</title>
    <link href="http://htuotuo.top/2018/02/24/Excel%E8%A7%A3%E6%9E%90%E5%92%8C%E7%94%9F%E6%88%90/"/>
    <id>http://htuotuo.top/2018/02/24/Excel解析和生成/</id>
    <published>2018-02-24T12:06:01.987Z</published>
    <updated>2018-02-24T12:32:48.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-导入maven坐标"><a href="#1-导入maven坐标" class="headerlink" title="1.导入maven坐标"></a>1.导入maven坐标</h2><pre><code>基于 maven 坐标导入 POI 支持poi… jar 解析 HSSFpoi ooxml .. jar 解析 XSSF （以来 POI 包 ）</code></pre><h2 id="解析-Excel-逻辑"><a href="#解析-Excel-逻辑" class="headerlink" title="解析 Excel 逻辑"></a>解析 Excel 逻辑</h2><pre><code>工作薄 --- sheet --- row --- cell基于struts2进行文件上传的并解析// 接收上传文件private File file;public void setFile(File file) {    this.file = file;}// 批量区域数据导入@Action(value = &quot;area_batchImport&quot;)public String batchImport() throws IOException {    //创建区域集合    List&lt;Area&gt; areas = new ArrayList&lt;Area&gt;();    // 编写解析代码逻辑    // 基于.xls 格式解析 HSSF，也可以直接使用父类Workbook,可以解析xls和xlsx    // 1、 加载Excel文件对象    HSSFWorkbook hssfWorkbook = new HSSFWorkbook(new FileInputStream(file));    // 2、 读取一个sheet    HSSFSheet sheet=hssfWorkbook.getSheetAt(0);    // 3、 读取sheet中每一行    for (Row row : sheet) {        // 一行数据 对应 一个区域对象        //根据自己导入的数据表格格式进行解析，通常第一行为表头直接跳过        if (row.getRowNum() == 0) {            // 第一行 跳过            continue;        }        // 跳过空行        if (row.getCell(0) == null                || StringUtils.isBlank(row.getCell(0).getStringCellValue())) {            continue;        }        Area area = new Area();        area.setId(row.getCell(0).getStringCellValue());        area.setProvince(row.getCell(1).getStringCellValue());        area.setCity(row.getCell(2).getStringCellValue());        area.setDistrict(row.getCell(3).getStringCellValue());        area.setPostcode(row.getCell(4).getStringCellValue());        // 基于pinyin4j生成城市编码和简码,导入pingyin4J的坐标        String province = area.getProvince();        String city = area.getCity();        String district = area.getDistrict();        //去除省市区后缀        province = province.substring(0, province.length() - 1);        city = city.substring(0, city.length() - 1);        district = district.substring(0, district.length() - 1);        // 简码        String[] headArray = PinYin4jUtils.getHeadByString(province + city                + district);        StringBuffer buffer = new StringBuffer();        for (String headStr : headArray) {            buffer.append(headStr);        }        String shortcode = buffer.toString();        area.setShortcode(shortcode);        // 城市编码        String citycode = PinYin4jUtils.hanziToPinyin(city, &quot;&quot;);        area.setCitycode(citycode);        areas.add(area);    }    // 调用业务层    areaService.saveBatch(areas);    return NONE;}</code></pre><h2 id="生成-Excel-逻辑"><a href="#生成-Excel-逻辑" class="headerlink" title="生成 Excel 逻辑"></a>生成 Excel 逻辑</h2><pre><code>编写 ReportAction 添加 exportXls 方法POI 生成 Excel 步骤写 Excel 过程一样，新建 Excel 文档 -- 新建 Sheet -- 新建 Row --新建 Cell 单元格 -- 写单元格数据POI 生成 HSSF （xls）和 XSSF （xlsx）// 导出运单 报表     @Action(&quot;report_exportXls&quot;)    public String exportXls() throws IOException {        // 查询出 满足当前条件 结果数据        List&lt;WayBill&gt; wayBills = wayBillService.findWayBills(model);        // 生成Excel文件        HSSFWorkbook hssfWorkbook = new HSSFWorkbook();        HSSFSheet sheet = hssfWorkbook.createSheet(&quot;运单数据&quot;);        // 表头        HSSFRow headRow = sheet.createRow(0);        headRow.createCell(0).setCellValue(&quot;运单号&quot;);        headRow.createCell(1).setCellValue(&quot;寄件人&quot;);        headRow.createCell(2).setCellValue(&quot;寄件人电话&quot;);        headRow.createCell(3).setCellValue(&quot;寄件人地址&quot;);        headRow.createCell(4).setCellValue(&quot;收件人&quot;);        headRow.createCell(5).setCellValue(&quot;收件人电话&quot;);        headRow.createCell(6).setCellValue(&quot;收件人地址&quot;);        // 表格数据        for (WayBill wayBill : wayBills) {            HSSFRow dataRow = sheet.createRow(sheet.getLastRowNum() + 1);            dataRow.createCell(0).setCellValue(wayBill.getWayBillNum());            dataRow.createCell(1).setCellValue(wayBill.getSendName());            dataRow.createCell(2).setCellValue(wayBill.getSendMobile());            dataRow.createCell(3).setCellValue(wayBill.getSendAddress());            dataRow.createCell(4).setCellValue(wayBill.getRecName());            dataRow.createCell(5).setCellValue(wayBill.getRecMobile());            dataRow.createCell(6).setCellValue(wayBill.getRecAddress());        }        // 下载导出        // 设置头信息        ServletActionContext.getResponse().setContentType(                &quot;application/vnd.ms-excel&quot;);        String filename = &quot;运单数据.xls&quot;;        //设置浏览器编码        String agent = ServletActionContext.getRequest()                .getHeader(&quot;user-agent&quot;);        filename = FileUtils.encodeDownloadFilename(filename, agent);        //设置文件头以下载形式打开        ServletActionContext.getResponse().setHeader(&quot;Content-Disposition&quot;,                &quot;attachment;filename=&quot; + filename);        ServletOutputStream outputStream = ServletActionContext.getResponse()                .getOutputStream();        hssfWorkbook.write(outputStream);        // 关闭        hssfWorkbook.close();        return NONE;    }</code></pre><h2 id="生成pdf文件"><a href="#生成pdf文件" class="headerlink" title="生成pdf文件"></a>生成pdf文件</h2><h3 id="使用java原生代码生成pdf文件"><a href="#使用java原生代码生成pdf文件" class="headerlink" title="使用java原生代码生成pdf文件"></a>使用java原生代码生成pdf文件</h3><pre><code>@Action(&quot;report_exportPdf&quot;)public String exportPdf() throws IOException, DocumentException {    // 查询出 满足当前条件 结果数据    List&lt;WayBill&gt; wayBills = wayBillService.findWayBills(model);    // 下载导出    // 设置头信息    ServletActionContext.getResponse().setContentType(&quot;application/pdf&quot;);    String filename = &quot;运单数据.pdf&quot;;    String agent = ServletActionContext.getRequest()            .getHeader(&quot;user-agent&quot;);    filename = FileUtils.encodeDownloadFilename(filename, agent);    ServletActionContext.getResponse().setHeader(&quot;Content-Disposition&quot;,            &quot;attachment;filename=&quot; + filename);    // 生成PDF文件    Document document = new Document();    PdfWriter.getInstance(document, ServletActionContext.getResponse()            .getOutputStream());    document.open();    // 写PDF数据    // 向document 生成pdf表格    Table table = new Table(7);    table.setWidth(80); // 宽度    table.setBorder(1); // 边框    table.getDefaultCell().setHorizontalAlignment(Element.ALIGN_CENTER); // 水平对齐方式    table.getDefaultCell().setVerticalAlignment(Element.ALIGN_TOP); // 垂直对齐方式    // 设置表格字体    BaseFont cn = BaseFont.createFont(&quot;STSongStd-Light&quot;, &quot;UniGB-UCS2-H&quot;,            false);    Font font = new Font(cn, 10, Font.NORMAL, Color.BLUE);    // 写表头    table.addCell(buildCell(&quot;运单号&quot;, font));    table.addCell(buildCell(&quot;寄件人&quot;, font));    table.addCell(buildCell(&quot;寄件人电话&quot;, font));    table.addCell(buildCell(&quot;寄件人地址&quot;, font));    table.addCell(buildCell(&quot;收件人&quot;, font));    table.addCell(buildCell(&quot;收件人电话&quot;, font));    table.addCell(buildCell(&quot;收件人地址&quot;, font));    // 写数据    for (WayBill wayBill : wayBills) {        table.addCell(buildCell(wayBill.getWayBillNum(), font));        table.addCell(buildCell(wayBill.getSendName(), font));        table.addCell(buildCell(wayBill.getSendMobile(), font));        table.addCell(buildCell(wayBill.getSendAddress(), font));        table.addCell(buildCell(wayBill.getRecName(), font));        table.addCell(buildCell(wayBill.getRecMobile(), font));        table.addCell(buildCell(wayBill.getRecAddress(), font));    }    // 将表格加入文档    document.add(table);    document.close();    return NONE;}private Cell buildCell(String content, Font font)        throws BadElementException {    Phrase phrase = new Phrase(content, font);    return new Cell(phrase);}</code></pre><h3 id="使用jasperReport技术生成pdf文件"><a href="#使用jasperReport技术生成pdf文件" class="headerlink" title="使用jasperReport技术生成pdf文件"></a>使用jasperReport技术生成pdf文件</h3><pre><code>    @Action(&quot;report_exportJasperPdf&quot;)    public String exportJasperPdf() throws IOException, DocumentException,            JRException, SQLException {        // 查询出 满足当前条件 结果数据        List&lt;WayBill&gt; wayBills = wayBillService.findWayBills(model);        // 下载导出        // 设置头信息        ServletActionContext.getResponse().setContentType(&quot;application/pdf&quot;);        String filename = &quot;运单数据.pdf&quot;;        String agent = ServletActionContext.getRequest()                .getHeader(&quot;user-agent&quot;);        filename = FileUtils.encodeDownloadFilename(filename, agent);        ServletActionContext.getResponse().setHeader(&quot;Content-Disposition&quot;,                &quot;attachment;filename=&quot; + filename);        // 根据 jasperReport模板 生成pdf,借助ireport工具生成模板        // 读取模板文件        String jrxml = ServletActionContext.getServletContext().getRealPath(                &quot;/WEB-INF/jasper/waybill.jrxml&quot;);        JasperReport report = JasperCompileManager.compileReport(jrxml);        // 设置模板数据，根据模板样式来设置参数        // Parameter变量        Map&lt;String, Object&gt; paramerters = new HashMap&lt;String, Object&gt;();        paramerters.put(&quot;company&quot;, &quot;传智播客&quot;);        // Field变量        JasperPrint jasperPrint = JasperFillManager.fillReport(report,                paramerters, new JRBeanCollectionDataSource(wayBills));        // 生成PDF客户端        JRPdfExporter exporter = new JRPdfExporter();        exporter.setParameter(JRExporterParameter.JASPER_PRINT, jasperPrint);        exporter.setParameter(JRExporterParameter.OUTPUT_STREAM,                ServletActionContext.getResponse().getOutputStream());        exporter.exportReport();// 导出        ServletActionContext.getResponse().getOutputStream().close();        return NONE;    }}</code></pre><h2 id="附加ireport工具使用"><a href="#附加ireport工具使用" class="headerlink" title="附加ireport工具使用"></a>附加ireport工具使用</h2><h2 id="IReport-报表模板简介和设置中文生成"><a href="#IReport-报表模板简介和设置中文生成" class="headerlink" title="IReport 报表模板简介和设置中文生成"></a>IReport 报表模板简介和设置中文生成</h2><h3 id="1、新建-JasperReport-模板文件-jrxml"><a href="#1、新建-JasperReport-模板文件-jrxml" class="headerlink" title="1、新建 JasperReport 模板文件 .jrxml"></a>1、新建 JasperReport 模板文件 .jrxml</h3><h3 id="2、设置默认语言"><a href="#2、设置默认语言" class="headerlink" title="2、设置默认语言"></a>2、设置默认语言</h3><pre><code>对输入中文内容 设置组件属性</code></pre><p><img src="https://i.imgur.com/H4eh44k.png" alt=""></p><pre><code>在 IReport 引入 ITextAsian.jar 字库在工具选项中    </code></pre><p><img src="https://i.imgur.com/hmOetdY.png" alt=""></p><h3 id="3、-了解报表模板结构"><a href="#3、-了解报表模板结构" class="headerlink" title="3、 了解报表模板结构"></a>3、 了解报表模板结构</h3><pre><code>Title: 报表标题PageHeader: 页眉ColumnHeader: 表格列标题Detail： 表格数据内容ColumnFooter： 表格页脚PageFooter： 页脚Summary: 摘要</code></pre><h3 id="4、-常用报表组件"><a href="#4、-常用报表组件" class="headerlink" title="4、 常用报表组件"></a>4、 常用报表组件</h3><p><img src="https://i.imgur.com/lZrtNKt.png" alt=""></p><pre><code>设置预览格式为 PDF</code></pre><h2 id="4-3．-IReport-配置数据库连接，基于数据表生成报表"><a href="#4-3．-IReport-配置数据库连接，基于数据表生成报表" class="headerlink" title="4.3． IReport 配置数据库连接，基于数据表生成报表"></a>4.3． IReport 配置数据库连接，基于数据表生成报表</h2><pre><code>1、 点击按钮配置数据库连接新建 JDBC 连接</code></pre><p><img src="https://i.imgur.com/VvJwgM5.png" alt=""><br>    2、 在 ireport 添加 oracle 的 jdbc 驱动<br><img src="https://i.imgur.com/qqPYAOd.png" alt=""><br><img src="https://i.imgur.com/uIXnf1h.png" alt=""><br>    3、 通过 ReportQuery 查询数据库<br><img src="https://i.imgur.com/vzo4vXn.png" alt=""><br><img src="https://i.imgur.com/TmPcw2t.png" alt=""><br>    4、 设计报表<br><img src="https://i.imgur.com/Qlhe23r.png" alt=""></p><h2 id="4-4．-JasperResport-根据模板文件-生成报表"><a href="#4-4．-JasperResport-根据模板文件-生成报表" class="headerlink" title="4.4． JasperResport 根据模板文件 生成报表"></a>4.4． JasperResport 根据模板文件 生成报表</h2><pre><code>1、 设置 ireport 字段 自动换行</code></pre><p><img src="https://i.imgur.com/HsGtGsM.png" alt=""></p><pre><code>2、 将 waybill.jrxml 复制 bos_management3、 在 waybill_manage.html 页面添加按钮4、 在 common-parent 导入 jasperReport 开发包5、 在 ReportAction 添加 exportJasperPdf 方法</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-导入maven坐标&quot;&gt;&lt;a href=&quot;#1-导入maven坐标&quot; class=&quot;headerlink&quot; title=&quot;1.导入maven坐标&quot;&gt;&lt;/a&gt;1.导入maven坐标&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;基于 maven 坐标导入 POI 支持
poi… 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://htuotuo.top/2018/02/10/hello-world/"/>
    <id>http://htuotuo.top/2018/02/10/hello-world/</id>
    <published>2018-02-09T18:05:24.525Z</published>
    <updated>2018-02-09T18:05:24.525Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
