<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tuotuo的博客</title>
  
  <subtitle>tuotuo</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://htuotuo.top/"/>
  <updated>2018-04-11T03:55:23.634Z</updated>
  <id>http://htuotuo.top/</id>
  
  <author>
    <name>tuotuo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见sql</title>
    <link href="http://htuotuo.top/2018/04/11/%E5%B8%B8%E7%94%A8sql/"/>
    <id>http://htuotuo.top/2018/04/11/常用sql/</id>
    <published>2018-04-11T03:53:31.902Z</published>
    <updated>2018-04-11T03:55:23.634Z</updated>
    
    <content type="html"><![CDATA[<pre><code>&lt;!-- 按日查询 --&gt;  SELECT DATE_FORMAT(created_date,&apos;%Y-%m-%d&apos;) as time,sum(money) money FROM o_finance_detail where org_id = 1000  GROUP BY  time  &lt;!-- 按月查询 --&gt;  SELECT DATE_FORMAT(created_date,&apos;%Y-%m&apos;) as time,sum(money)  money FROM o_finance_detail where org_id = 1000  GROUP BY  time  &lt;!-- 按年查询 --&gt;  SELECT DATE_FORMAT(created_date,&apos;%Y&apos;) as time,sum(money)  money FROM o_finance_detail where org_id = 1000  GROUP BY  time   &lt;!-- 按周查询 --&gt;  SELECT DATE_FORMAT(created_date,&apos;%Y-%u&apos;) as time,sum(money)  money FROM o_finance_detail where org_id = 1000  GROUP BY  time   DATE_FORMAT(date,format):根据format字符串格式化date值。下列修饰符可以被用在format字符串中： %M 月名字(January……December) %W 星期名字(Sunday……Saturday) %D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） %Y 年, 数字, 4 位 %y 年, 数字, 2 位 %a 缩写的星期名字(Sun……Sat) %d 月份中的天数, 数字(00……31) %e 月份中的天数, 数字(0……31) %m 月, 数字(01……12) %c 月, 数字(1……12) %b 缩写的月份名字(Jan……Dec) %j 一年中的天数(001……366) %H 小时(00……23) %k 小时(0……23) %h 小时(01……12) %I 小时(01……12) %l 小时(1……12) %i 分钟, 数字(00……59) %r 时间,12 小时(hh:mm:ss [AP]M) %T 时间,24 小时(hh:mm:ss) %S 秒(00……59) %s 秒(00……59) %p AM或PM %w 一个星期中的天数(0=Sunday ……6=Saturday ） %U 星期(0……52), 这里星期天是星期的第一天 %u 星期(0……52), 这里星期一是星期的第一天 %% 一个文字“%”。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;&amp;lt;!-- 按日查询 --&amp;gt;  
SELECT DATE_FORMAT(created_date,&amp;apos;%Y-%m-%d&amp;apos;) as time,sum(money) money FROM o_finance_detail where 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>solr单机版和集群的搭建</title>
    <link href="http://htuotuo.top/2018/03/08/solr%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://htuotuo.top/2018/03/08/solr集群搭建/</id>
    <published>2018-03-08T07:06:36.668Z</published>
    <updated>2018-03-08T08:00:47.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="solr单机版搭建"><a href="#solr单机版搭建" class="headerlink" title="solr单机版搭建"></a>solr单机版搭建</h1><h2 id="Solr的环境"><a href="#Solr的环境" class="headerlink" title="Solr的环境"></a>Solr的环境</h2><pre><code>Solr是java开发。需要安装jdk。安装环境Linux。需要安装Tomcat。</code></pre><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><pre><code>第一步：把solr 的压缩包上传到Linux系统第二步：解压solr。第三步：安装Tomcat，解压缩即可。第四步：把solr部署到Tomcat下。第五步：解压缩war包。启动Tomcat解压。第六步：把/root/solr-4.10.3/example/lib/ext目录下的所有的jar包，添加到solr工程中。[root@localhost ext]# pwd/root/solr-4.10.3/example/lib/ext[root@localhost ext]# cp * /usr/local/solr/tomcat/webapps/solr/WEB-INF/lib/第七步：创建一个solrhome。/example/solr目录就是一个solrhome。复制此目录到/usr/local/solr/solrhome[root@localhost example]# pwd/root/solr-4.10.3/example[root@localhost example]# cp -r solr /usr/local/solr/solrhome[root@localhost example]# 第八步：关联solr及solrhome。需要修改solr工程的web.xml文件。</code></pre><p><img src="https://i.imgur.com/Vhkt3Y1.png" alt="">        </p><pre><code>第九步：启动Tomcathttp://192.168.25.154:8080/solr/和windows下的配置完全一样。</code></pre><h3 id="Solr的使用"><a href="#Solr的使用" class="headerlink" title="Solr的使用"></a>Solr的使用</h3><pre><code>添加文档必须有id域，其他域 必须在solr的schema.xml中定义</code></pre><h2 id="配置业务域"><a href="#配置业务域" class="headerlink" title="配置业务域"></a>配置业务域</h2><pre><code>schema.xml中定义1、商品Id2、商品标题3、商品卖点4、商品价格5、商品图片6、分类名称7、商品描述创建对应的业务域。需要制定中文分析器。创建步骤：第一步：把中文分析器添加到工程中。1、把IKAnalyzer2012FF_u1.jar添加到solr工程的lib目录下2、把扩展词典、配置文件放到solr工程的WEB-INF/classes目录下。第二步：配置一个FieldType，制定使用IKAnalyzer修改schema.xml文件修改Solr的schema.xml文件，添加FieldType：&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;  &lt;analyzer class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;&lt;/fieldType&gt;第三步：配置业务域，type制定使用自定义的FieldType。设置业务系统Field&lt;field name=&quot;item_title&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_sell_point&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_price&quot;  type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_image&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_category_name&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_desc&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; /&gt;&lt;field name=&quot;item_keywords&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt;&lt;copyField source=&quot;item_title&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_sell_point&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_category_name&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_desc&quot; dest=&quot;item_keywords&quot;/&gt;第四步：重启tomcat</code></pre><h2 id="使用solrJ管理索引库"><a href="#使用solrJ管理索引库" class="headerlink" title="使用solrJ管理索引库"></a>使用solrJ管理索引库</h2><pre><code>使用SolrJ可以实现索引库的增删改查操作。</code></pre><h3 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h3><pre><code>第一步：把solrJ的jar包添加到工程中。第二步：创建一个SolrServer，使用HttpSolrServer创建对象。第三步：创建一个文档对象SolrInputDocument对象。第四步：向文档中添加域。必须有id域，域的名称必须在schema.xml中定义。第五步：把文档添加到索引库中。第六步：提交。@Testpublic void addDocument() throws Exception {    // 第一步：把solrJ的jar包添加到工程中。    // 第二步：创建一个SolrServer，使用HttpSolrServer创建对象。    SolrServer solrServer = new HttpSolrServer(&quot;http://192.168.25.154:8080/solr&quot;);    // 第三步：创建一个文档对象SolrInputDocument对象。    SolrInputDocument document = new SolrInputDocument();    // 第四步：向文档中添加域。必须有id域，域的名称必须在schema.xml中定义。    document.addField(&quot;id&quot;, &quot;test001&quot;);    document.addField(&quot;item_title&quot;, &quot;测试商品&quot;);    document.addField(&quot;item_price&quot;, &quot;199&quot;);    // 第五步：把文档添加到索引库中。    solrServer.add(document);    // 第六步：提交。    solrServer.commit();}</code></pre><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><h4 id="根据id删除"><a href="#根据id删除" class="headerlink" title="根据id删除"></a>根据id删除</h4><pre><code>第一步：创建一个SolrServer对象。第二步：调用SolrServer对象的根据id删除的方法。第三步：提交。@Testpublic void deleteDocumentById() throws Exception {    // 第一步：创建一个SolrServer对象。    SolrServer solrServer = new HttpSolrServer(&quot;http://192.168.25.154:8080/solr&quot;);    // 第二步：调用SolrServer对象的根据id删除的方法。    solrServer.deleteById(&quot;1&quot;);    // 第三步：提交。    solrServer.commit();}</code></pre><h4 id="根据查询删除"><a href="#根据查询删除" class="headerlink" title="根据查询删除"></a>根据查询删除</h4><pre><code>@Testpublic void deleteDocumentByQuery() throws Exception {    SolrServer solrServer = new HttpSolrServer(&quot;http://192.168.25.154:8080/solr&quot;);    solrServer.deleteByQuery(&quot;title:change.me&quot;);    solrServer.commit();}</code></pre><h4 id="查询索引库"><a href="#查询索引库" class="headerlink" title="查询索引库"></a>查询索引库</h4><pre><code>查询步骤：第一步：创建一个SolrServer对象第二步：创建一个SolrQuery对象。第三步：向SolrQuery中添加查询条件、过滤条件。。。第四步：执行查询。得到一个Response对象。第五步：取查询结果。第六步：遍历结果并打印。</code></pre><h4 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h4><pre><code>@Testpublic void queryDocument() throws Exception {    // 第一步：创建一个SolrServer对象    SolrServer solrServer = new HttpSolrServer(&quot;http://192.168.25.154:8080/solr&quot;);    // 第二步：创建一个SolrQuery对象。    SolrQuery query = new SolrQuery();    // 第三步：向SolrQuery中添加查询条件、过滤条件。。。    query.setQuery(&quot;*:*&quot;);    // 第四步：执行查询。得到一个Response对象。    QueryResponse response = solrServer.query(query);    // 第五步：取查询结果。    SolrDocumentList solrDocumentList = response.getResults();    System.out.println(&quot;查询结果的总记录数：&quot; + solrDocumentList.getNumFound());    // 第六步：遍历结果并打印。    for (SolrDocument solrDocument : solrDocumentList) {        System.out.println(solrDocument.get(&quot;id&quot;));        System.out.println(solrDocument.get(&quot;item_title&quot;));        System.out.println(solrDocument.get(&quot;item_price&quot;));    }}</code></pre><h4 id="带高亮显示"><a href="#带高亮显示" class="headerlink" title="带高亮显示"></a>带高亮显示</h4><pre><code>@Testpublic void queryDocumentWithHighLighting() throws Exception {    // 第一步：创建一个SolrServer对象    SolrServer solrServer = new HttpSolrServer(&quot;http://192.168.25.154:8080/solr&quot;);    // 第二步：创建一个SolrQuery对象。    SolrQuery query = new SolrQuery();    // 第三步：向SolrQuery中添加查询条件、过滤条件。。。    query.setQuery(&quot;测试&quot;);    //指定默认搜索域    query.set(&quot;df&quot;, &quot;item_keywords&quot;);    //开启高亮显示    query.setHighlight(true);    //高亮显示的域    query.addHighlightField(&quot;item_title&quot;);    query.setHighlightSimplePre(&quot;&lt;em&gt;&quot;);    query.setHighlightSimplePost(&quot;&lt;/em&gt;&quot;);    // 第四步：执行查询。得到一个Response对象。    QueryResponse response = solrServer.query(query);    // 第五步：取查询结果。    SolrDocumentList solrDocumentList = response.getResults();    System.out.println(&quot;查询结果的总记录数：&quot; + solrDocumentList.getNumFound());    // 第六步：遍历结果并打印。    for (SolrDocument solrDocument : solrDocumentList) {        System.out.println(solrDocument.get(&quot;id&quot;));        //取高亮显示        Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = response.getHighlighting();        List&lt;String&gt; list = highlighting.get(solrDocument.get(&quot;id&quot;)).get(&quot;item_title&quot;);        String itemTitle = null;        if (list != null &amp;&amp; list.size() &gt; 0) {            itemTitle = list.get(0);        } else {            itemTitle = (String) solrDocument.get(&quot;item_title&quot;);        }        System.out.println(itemTitle);        System.out.println(solrDocument.get(&quot;item_price&quot;));    }}</code></pre><h1 id="solr集群搭建"><a href="#solr集群搭建" class="headerlink" title="solr集群搭建"></a>solr集群搭建</h1><h2 id="什么是SolrCloud"><a href="#什么是SolrCloud" class="headerlink" title="什么是SolrCloud"></a>什么是SolrCloud</h2><pre><code>olrCloud(solr 云)是Solr提供的分布式搜索方案，当你需要大规模，容错，分布式索引和检索能力时使用 SolrCloud。当一个系统的索引数据量少的时候是不需要使用SolrCloud的，当索引量很大，搜索请求并发很高，这时需要使用SolrCloud来满足这些需求。 SolrCloud是基于Solr和Zookeeper的分布式搜索方案，它的主要思想是使用Zookeeper作为集群的配置信息中心。它有几个特色功能：1）集中式的配置信息2）自动容错3）近实时搜索4）查询时自动负载均衡</code></pre><h2 id="Solr集群的系统架构"><a href="#Solr集群的系统架构" class="headerlink" title="Solr集群的系统架构"></a>Solr集群的系统架构</h2><p><img src="https://i.imgur.com/jE9Bdud.png" alt=""></p><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><pre><code>三个Solr实例（ 每个实例包括两个Core），组成一个SolrCloud。</code></pre><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><pre><code>索引集合包括两个Shard（shard1和shard2），shard1和shard2分别由三个Core组成，其中一个Leader两个Replication，Leader是由zookeeper选举产生，zookeeper控制每个shard上三个Core的索引数据一致，解决高可用问题。用户发起索引请求分别从shard1和shard2上获取，解决高并发问题。</code></pre><h4 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h4><pre><code>Collection在SolrCloud集群中是一个逻辑意义上的完整的索引结构。它常常被划分为一个或多个Shard（分片），它们使用相同的配置信息。比如：针对商品信息搜索可以创建一个collection。 collection=shard1+shard2+....+shardX</code></pre><h4 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h4><pre><code>每个Core是Solr中一个独立运行单位，提供 索引和搜索服务。一个shard需要由一个Core或多个Core组成。由于collection由多个shard组成所以collection一般由多个core组成。</code></pre><h4 id="Master或Slave"><a href="#Master或Slave" class="headerlink" title="Master或Slave"></a>Master或Slave</h4><pre><code>Master是master-slave结构中的主结点（通常说主服务器），Slave是master-slave结构中的从结点（通常说从服务器或备服务器）。同一个Shard下master和slave存储的数据是一致的，这是为了达到高可用目的。</code></pre><h4 id="Shard"><a href="#Shard" class="headerlink" title="Shard"></a>Shard</h4><pre><code>Collection的逻辑分片。每个Shard被化成一个或者多个replication，通过选举确定哪个是Leader。</code></pre><h2 id="需要实现的solr集群架构"><a href="#需要实现的solr集群架构" class="headerlink" title="需要实现的solr集群架构"></a>需要实现的solr集群架构</h2><p><img src="https://i.imgur.com/PNRFZEL.png" alt=""></p><pre><code>Zookeeper作为集群的管理工具。1、集群管理：容错、负载均衡。2、配置文件的集中管理3、集群的入口需要实现zookeeper 高可用。需要搭建集群。建议是奇数节点。需要三个zookeeper服务器。搭建solr集群需要7台服务器。搭建伪分布式：需要三个zookeeper节点需要四个tomcat节点。建议虚拟机的内容1G以上。</code></pre><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="Zookeeper集群搭建"><a href="#Zookeeper集群搭建" class="headerlink" title="Zookeeper集群搭建"></a>Zookeeper集群搭建</h3><pre><code>第一步：需要安装jdk环境。第二步：把zookeeper的压缩包上传到服务器。第三步：解压缩。第四步：把zookeeper复制三份。[root@localhost ~]# mkdir /usr/local/solr-cloud[root@localhost ~]# cp -r zookeeper-3.4.6 /usr/local/solr-cloud/zookeeper01[root@localhost ~]# cp -r zookeeper-3.4.6 /usr/local/solr-cloud/zookeeper02[root@localhost ~]# cp -r zookeeper-3.4.6 /usr/local/solr-cloud/zookeeper03第五步：在每个zookeeper目录下创建一个data目录。第六步：在data目录下创建一个myid文件，文件名就叫做“myid”。内容就是每个实例的id。例如1、2、3[root@localhost data]# echo 1 &gt;&gt; myid[root@localhost data]# lltotal 4-rw-r--r--. 1 root root 2 Apr  7 18:23 myid[root@localhost data]# cat myid 1第七步：修改配置文件。把conf目录下的zoo_sample.cfg文件改名为zoo.cfg</code></pre><p><img src="https://i.imgur.com/JT2N97D.png" alt=""></p><pre><code>server.1=192.168.25.154:2881:3881server.2=192.168.25.154:2882:3882server.3=192.168.25.154:2883:3883第八步：启动每个zookeeper实例。启动bin/zkServer.sh start查看zookeeper的状态：bin/zkServer.sh status</code></pre><h2 id="Solr集群的搭建"><a href="#Solr集群的搭建" class="headerlink" title="Solr集群的搭建"></a>Solr集群的搭建</h2><pre><code>第一步：创建四个tomcat实例。每个tomcat运行在不同的端口。8180、8280、8380、8480第二步：部署solr的war包。把单机版的solr工程复制到集群中的tomcat中。第三步：为每个solr实例创建一个对应的solrhome。使用单机版的solrhome复制四份。第四步：需要修改solr的web.xml文件。把solrhome关联起来。第五步：配置solrCloud相关的配置。每个solrhome下都有一个solr.xml，把其中的ip及端口号配置好。</code></pre><p><img src="https://i.imgur.com/aHjY2tm.png" alt=""></p><pre><code>第六步：让zookeeper统一管理配置文件。需要把solrhome/collection1/conf目录上传到zookeeper。上传任意solrhome中的配置文件即可。使用工具上传配置文件：/root/solr-4.10.3/example/scripts/cloud-scripts/zkcli.sh./zkcli.sh -zkhost 192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183 -cmd upconfig -confdir /usr/local/solr-cloud/solrhome01/collection1/conf -confname myconf查看zookeeper上的配置文件：使用zookeeper目录下的bin/zkCli.sh命令查看zookeeper上的配置文件：[root@localhost bin]# ./zkCli.sh [zk: localhost:2181(CONNECTED) 0] ls /[configs, zookeeper][zk: localhost:2181(CONNECTED) 1] ls /configs[myconf][zk: localhost:2181(CONNECTED) 2] ls /configs/myconf[admin-extra.menu-top.html, currency.xml, protwords.txt, mapping-FoldToASCII.txt, _schema_analysis_synonyms_english.json, _rest_managed.json, solrconfig.xml, _schema_analysis_stopwords_english.json, stopwords.txt, lang, spellings.txt, mapping-ISOLatin1Accent.txt, admin-extra.html, xslt, synonyms.txt, scripts.conf, update-script.js, velocity, elevate.xml, admin-extra.menu-bottom.html, clustering, schema.xml][zk: localhost:2181(CONNECTED) 3] 退出：[zk: localhost:2181(CONNECTED) 3] quit第七步：修改tomcat/bin目录下的catalina.sh 文件，关联solr和zookeeper。把此配置添加到配置文件中：JAVA_OPTS=&quot;-DzkHost=192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183&quot;</code></pre><p><img src="https://i.imgur.com/ApPY8hw.png" alt=""></p><pre><code>第八步：启动每个tomcat实例。要保证zookeeper集群是启动状态。第九步：访问集群</code></pre><p><img src="https://i.imgur.com/jdPnUdR.png" alt=""></p><pre><code>第十步：创建新的Collection进行分片处理。http://192.168.25.154:8180/solr/admin/collections?action=CREATE&amp;name=collection2&amp;numShards=2&amp;replicationFactor=2</code></pre><p><img src="https://i.imgur.com/0D9jLX2.png" alt="">    </p><pre><code>第十一步：删除不用的Collection。http://192.168.25.154:8180/solr/admin/collections?action=DELETE&amp;name=collection1</code></pre><p><img src="https://i.imgur.com/VjGEBlb.png" alt=""></p><p><img src="https://i.imgur.com/qFnjlKI.png" alt=""></p><h2 id="使用solrJ管理集群"><a href="#使用solrJ管理集群" class="headerlink" title="使用solrJ管理集群"></a>使用solrJ管理集群</h2><h3 id="添加文档-1"><a href="#添加文档-1" class="headerlink" title="添加文档"></a>添加文档</h3><pre><code>使用步骤：第一步：把solrJ相关的jar包添加到工程中。第二步：创建一个SolrServer对象，需要使用CloudSolrServer子类。构造方法的参数是zookeeper的地址列表。第三步：需要设置DefaultCollection属性。第四步：创建一SolrInputDocument对象。第五步：向文档对象中添加域第六步：把文档对象写入索引库。第七步：提交。@Test    public void testSolrCloudAddDocument() throws Exception {        // 第一步：把solrJ相关的jar包添加到工程中。        // 第二步：创建一个SolrServer对象，需要使用CloudSolrServer子类。构造方法的参数是zookeeper的地址列表。        //参数是zookeeper的地址列表，使用逗号分隔        CloudSolrServer solrServer = new CloudSolrServer(&quot;192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183&quot;);        // 第三步：需要设置DefaultCollection属性。        solrServer.setDefaultCollection(&quot;collection2&quot;);        // 第四步：创建一SolrInputDocument对象。        SolrInputDocument document = new SolrInputDocument();        // 第五步：向文档对象中添加域        document.addField(&quot;item_title&quot;, &quot;测试商品&quot;);        document.addField(&quot;item_price&quot;, &quot;100&quot;);        document.addField(&quot;id&quot;, &quot;test001&quot;);        // 第六步：把文档对象写入索引库。        solrServer.add(document);        // 第七步：提交。        solrServer.commit();    }</code></pre><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><pre><code>创建一个CloudSolrServer对象，其他处理和单机版一致。</code></pre><h2 id="把搜索功能切换到集群版-spring整合solr配置文件"><a href="#把搜索功能切换到集群版-spring整合solr配置文件" class="headerlink" title="把搜索功能切换到集群版(spring整合solr配置文件)"></a>把搜索功能切换到集群版(spring整合solr配置文件)</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans4.2.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context4.2.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx4.2.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util4.2.xsd&quot;&gt;    &lt;!-- 单机版solr服务配置 --&gt;    &lt;!-- &lt;bean id=&quot;httpSolrServer&quot; class=&quot;org.apache.solr.client.solrj.impl.HttpSolrServer&quot;&gt;        &lt;constructor-arg name=&quot;baseURL&quot; value=&quot;http://192.168.25.154:8080/solr&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt; --&gt;    &lt;!-- 集群版solr服务 --&gt;    &lt;bean id=&quot;cloudSolrServer&quot; class=&quot;org.apache.solr.client.solrj.impl.CloudSolrServer&quot;&gt;        &lt;constructor-arg name=&quot;zkHost&quot; value=&quot;192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183&quot;&gt;&lt;/constructor-arg&gt;            &lt;property name=&quot;defaultCollection&quot; value=&quot;collection2&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;solr单机版搭建&quot;&gt;&lt;a href=&quot;#solr单机版搭建&quot; class=&quot;headerlink&quot; title=&quot;solr单机版搭建&quot;&gt;&lt;/a&gt;solr单机版搭建&lt;/h1&gt;&lt;h2 id=&quot;Solr的环境&quot;&gt;&lt;a href=&quot;#Solr的环境&quot; class=&quot;he
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网页静态化部署方案</title>
    <link href="http://htuotuo.top/2018/03/08/%E7%BD%91%E9%A1%B5%E9%9D%99%E6%80%81%E5%8C%96%E6%96%B9%E6%A1%88/"/>
    <id>http://htuotuo.top/2018/03/08/网页静态化方案/</id>
    <published>2018-03-08T07:06:32.560Z</published>
    <updated>2018-03-08T13:40:54.473Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是freemarker"><a href="#什么是freemarker" class="headerlink" title="什么是freemarker"></a>什么是freemarker</h2><pre><code>FreeMarker是一个用Java语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker与Web容器无关，即在Web运行时，它并不知道Servlet或HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生成XML，JSP或Java 等。目前企业中:主要用Freemarker做静态页面或是页面展示</code></pre><h2 id="Freemarker的使用方法"><a href="#Freemarker的使用方法" class="headerlink" title="Freemarker的使用方法"></a>Freemarker的使用方法</h2><pre><code>把freemarker的jar包添加到工程中。Maven工程添加依赖&lt;dependency&gt;  &lt;groupId&gt;org.freemarker&lt;/groupId&gt;  &lt;artifactId&gt;freemarker&lt;/artifactId&gt;  &lt;version&gt;2.3.23&lt;/version&gt;&lt;/dependency&gt;原理：</code></pre><p><img src="https://i.imgur.com/xrT57yt.png" alt=""></p><pre><code>使用步骤：第一步：创建一个Configuration对象，直接new一个对象。构造方法的参数就是freemarker对于的版本号。第二步：设置模板文件所在的路径。第三步：设置模板文件使用的字符集。一般就是utf-8.第四步：加载一个模板，创建一个模板对象。第五步：创建一个模板使用的数据集，可以是pojo也可以是map。一般是Map。第六步：创建一个Writer对象，一般创建一FileWriter对象，指定生成的文件名。第七步：调用模板对象的process方法输出文件。第八步：关闭流。模板：${hello}@Test    public void genFile() throws Exception {        // 第一步：创建一个Configuration对象，直接new一个对象。构造方法的参数就是freemarker对于的版本号。        Configuration configuration = new Configuration(Configuration.getVersion());        // 第二步：设置模板文件所在的路径。        configuration.setDirectoryForTemplateLoading(new File(&quot;D:/workspaces-itcast/term197/taotao-item-web/src/main/webapp/WEB-INF/ftl&quot;));        // 第三步：设置模板文件使用的字符集。一般就是utf-8.        configuration.setDefaultEncoding(&quot;utf-8&quot;);        // 第四步：加载一个模板，创建一个模板对象。        Template template = configuration.getTemplate(&quot;hello.ftl&quot;);        // 第五步：创建一个模板使用的数据集，可以是pojo也可以是map。一般是Map。        Map dataModel = new HashMap&lt;&gt;();        //向数据集中添加数据        dataModel.put(&quot;hello&quot;, &quot;this is my first freemarker test.&quot;);        // 第六步：创建一个Writer对象，一般创建一FileWriter对象，指定生成的文件名。        Writer out = new FileWriter(new File(&quot;D:/temp/term197/out/hello.html&quot;));        // 第七步：调用模板对象的process方法输出文件。        template.process(dataModel, out);        // 第八步：关闭流。        out.close();    }</code></pre><h2 id="模板的语法"><a href="#模板的语法" class="headerlink" title="模板的语法"></a>模板的语法</h2><h3 id="访问map中的key"><a href="#访问map中的key" class="headerlink" title="访问map中的key"></a>访问map中的key</h3><pre><code>${key}</code></pre><h3 id="访问pojo中的属性"><a href="#访问pojo中的属性" class="headerlink" title="访问pojo中的属性"></a>访问pojo中的属性</h3><pre><code>Student对象。学号、姓名、年龄    ${key.property}</code></pre><p><img src="https://i.imgur.com/denQMyY.png" alt="">    </p><h3 id="取集合中的数据"><a href="#取集合中的数据" class="headerlink" title="取集合中的数据"></a>取集合中的数据</h3><pre><code>&lt;#list studentList as student&gt;${student.id}/${studnet.name}&lt;/#list&gt;</code></pre><p><img src="https://i.imgur.com/hsPdq1m.png" alt="">    </p><h3 id="取循环中的下标"><a href="#取循环中的下标" class="headerlink" title="取循环中的下标"></a>取循环中的下标</h3><pre><code>&lt;#list studentList as student&gt;    ${student_index}&lt;/#list&gt;</code></pre><p><img src="https://i.imgur.com/tsz24ub.png" alt=""></p><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><pre><code>&lt;#if student_index % 2 == 0&gt;&lt;#else&gt;&lt;/#if&gt;</code></pre><p><img src="https://i.imgur.com/90FWwMP.png" alt=""></p><h3 id="日期类型格式化"><a href="#日期类型格式化" class="headerlink" title="日期类型格式化"></a>日期类型格式化</h3><p><img src="https://i.imgur.com/bkw4EHY.png" alt=""></p><h3 id="Null值的处理"><a href="#Null值的处理" class="headerlink" title="Null值的处理"></a>Null值的处理</h3><p><img src="https://i.imgur.com/2IDab6Q.png" alt=""></p><h3 id="Include标签"><a href="#Include标签" class="headerlink" title="Include标签"></a>Include标签</h3><pre><code>&lt;#include “模板名称”&gt;</code></pre><p><img src="https://i.imgur.com/dRDgPLz.png" alt=""></p><h2 id="Freemarker整合spring"><a href="#Freemarker整合spring" class="headerlink" title="Freemarker整合spring"></a>Freemarker整合spring</h2><pre><code>引入jar包：Freemarker的jar包</code></pre><p><img src="https://i.imgur.com/EDPI8ud.png" alt=""></p><h2 id="静态化页面生成的逻辑："><a href="#静态化页面生成的逻辑：" class="headerlink" title="静态化页面生成的逻辑："></a>静态化页面生成的逻辑：</h2><pre><code>1.输出文件名称为“商品id”+“html”2.输出文件的路径：工程外部的任意目录3.网页访问：使用nginx访问网页，在此方法下Tomcat只用来生成静态页面，因为nginx访问速度比Tomcat快的多4.工程部署：把商品详情系统部署到多个服务器上5.生成静态页面时机：商品添加后将商品ID通过activeMQ保存到message中产生生成者，消费者方通过监听，得到商品ID，进行生成静态页面</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是freemarker&quot;&gt;&lt;a href=&quot;#什么是freemarker&quot; class=&quot;headerlink&quot; title=&quot;什么是freemarker&quot;&gt;&lt;/a&gt;什么是freemarker&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;FreeMarker是一个用Java
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nginx的linux安装</title>
    <link href="http://htuotuo.top/2018/03/04/nginx%E5%AE%89%E8%A3%85/"/>
    <id>http://htuotuo.top/2018/03/04/nginx安装/</id>
    <published>2018-03-04T07:46:43.348Z</published>
    <updated>2018-02-27T15:07:32.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要求的安装环境"><a href="#要求的安装环境" class="headerlink" title="要求的安装环境"></a>要求的安装环境</h2><p><strong>1、需要安装gcc的环境。yum install gcc-c++</strong></p><p><strong>2、第三方的开发包。</strong></p><pre><code>pcrepcre(perl compatible regular expressions)是一个perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库。yum install -y pcre pcre-devel注：pcre-devel是使用pcre开发的一个二次开发库。nginx也需要此库。zlibzlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。yum install -y zlib zlib-developensslOpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。yum install -y openssl openssl-devel</code></pre><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><pre><code>第一步：把nginx的源码包上传到linux系统第二步：解压缩[root@localhost ~]# tar zxf nginx-1.8.0.tar.gz 第三步：使用configure命令创建一makeFile文件。./configure \--prefix=/usr/local/nginx \--pid-path=/var/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--with-http_gzip_static_module \--http-client-body-temp-path=/var/temp/nginx/client \--http-proxy-temp-path=/var/temp/nginx/proxy \--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \--http-scgi-temp-path=/var/temp/nginx/scgi注意：启动nginx之前，上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录如果出现以下：</code></pre><p><img src="https://i.imgur.com/N3JIBmF.png" alt=""></p><pre><code>解决：gcc没有安装  yum install gcc 即可[root@localhost sbin]# mkdir /var/temp/nginx/client -p第四步：make第五步：make install</code></pre><p><img src="https://i.imgur.com/Lykjxwx.png" alt=""></p><h3 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h3><pre><code>进入sbin目录[root@localhost sbin]# ./nginx</code></pre><p><img src="https://i.imgur.com/KgvKP9q.png" alt=""></p><pre><code>关闭nginx：[root@localhost sbin]# ./nginx -s stop推荐使用：[root@localhost sbin]# ./nginx -s quit重启nginx：1、先关闭后启动。2、刷新配置文件：[root@localhost sbin]# ./nginx -s reload</code></pre><h3 id="访问nginx"><a href="#访问nginx" class="headerlink" title="访问nginx"></a>访问nginx</h3><p><img src="https://i.imgur.com/9lborXy.png" alt=""></p><pre><code>默认是80端口。注意：是否关闭防火墙。</code></pre><h2 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h2><pre><code>就是在一台服务器启动多个网站。如何区分不同的网站：1、域名不同2、端口不同</code></pre><h3 id="通过端口区分不同虚拟机"><a href="#通过端口区分不同虚拟机" class="headerlink" title="通过端口区分不同虚拟机"></a>通过端口区分不同虚拟机</h3><pre><code>Nginx的配置文件：/usr/local/nginx/conf/nginx.conf#user  nobody;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events {worker_connections  1024;}http {include       mime.types;default_type  application/octet-stream;#log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;#                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;#                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;#access_log  logs/access.log  main;sendfile        on;#tcp_nopush     on;#keepalive_timeout  0;keepalive_timeout  65;server {    listen       80;    server_name  localhost;    location / {        root   html;        index  index.html index.htm;    }}}可以配置多个server，配置了多个虚拟主机。添加虚拟主机：#user  nobody;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    server {        listen       80;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            root   html;            index  index.html index.htm;        }    }    server {        listen       81;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            root   html-81;            index  index.html index.htm;        }    }}重新加载配置文件[root@localhost nginx]# sbin/nginx -s reload</code></pre><h3 id="通过域名区分虚拟主机"><a href="#通过域名区分虚拟主机" class="headerlink" title="通过域名区分虚拟主机"></a>通过域名区分虚拟主机</h3><h4 id="什么是域名"><a href="#什么是域名" class="headerlink" title="什么是域名"></a>什么是域名</h4><pre><code>域名就是网站。www.baidu.comwww.taobao.comwww.jd.comTcp/ipDns服务器：把域名解析为ip地址。保存的就是域名和ip的映射关系。一级域名：Baidu.comTaobao.comJd.com二级域名：www.baidu.comImage.baidu.comItem.baidu.com三级域名：1.Image.baidu.comAaa.image.baidu.com一个域名对应一个ip地址，一个ip地址可以被多个域名绑定。本地测试可以修改host文件。修改window的hosts文件：（C:\Windows\System32\drivers\etc）可以配置域名和ip的映射关系，如果hosts文件中配置了域名和ip的对应关系，不需要走dns服务器。</code></pre><p><img src="https://i.imgur.com/e0RDxxi.png" alt=""></p><h4 id="Nginx的配置"><a href="#Nginx的配置" class="headerlink" title="Nginx的配置"></a>Nginx的配置</h4><pre><code>#user  nobody;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;    #gzip  on;    server {        listen       80;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            root   html;            index  index.html index.htm;        }    }    server {        listen       81;        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            root   html-81;            index  index.html index.htm;        }    }    server {        listen       80;        server_name  www.taobao.com;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            root   html-taobao;            index  index.html index.htm;        }    }    server {        listen       80;        server_name  www.baidu.com;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            root   html-baidu;            index  index.html index.htm;        }    }}域名的配置：192.168.25.148 www.taobao.com192.168.25.148 www.baidu.com</code></pre><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="什么是反向代理"><a href="#什么是反向代理" class="headerlink" title="什么是反向代理"></a>什么是反向代理</h3><pre><code>正向代理</code></pre><p><img src="https://i.imgur.com/bduvX1I.png" alt=""></p><p>反向代理：<br><img src="https://i.imgur.com/Mk1cj4m.png" alt=""></p><pre><code>反向代理服务器决定哪台服务器提供服务。返回代理服务器不提供服务器。也是请求的转发。</code></pre><h3 id="Nginx实现反向代理"><a href="#Nginx实现反向代理" class="headerlink" title="Nginx实现反向代理"></a>Nginx实现反向代理</h3><pre><code>两个域名指向同一台nginx服务器，用户访问不同的域名显示不同的网页内容。两个域名是www.sian.com.cn和www.sohu.comnginx服务器使用虚拟机192.168.101.3 </code></pre><p><img src="https://i.imgur.com/letuWQy.png" alt=""></p><pre><code>第一步：安装两个tomcat，分别运行在8080和8081端口。第二步：启动两个tomcat。第三步：反向代理服务器的配置upstream tomcat1 {server 192.168.25.148:8080;}server {    listen       80;    server_name  www.sina.com.cn;    #charset koi8-r;    #access_log  logs/host.access.log  main;    location / {        proxy_pass   http://tomcat1;        index  index.html index.htm;    }}upstream tomcat2 {server 192.168.25.148:8081;}server {    listen       80;    server_name  www.sohu.com;    #charset koi8-r;    #access_log  logs/host.access.log  main;    location / {        proxy_pass   http://tomcat2;        index  index.html index.htm;    }}第四步：nginx重新加载配置文件第五步：配置域名在hosts文件中添加域名和ip的映射关系192.168.25.148 www.sina.com.cn192.168.25.148 www.sohu.com7.负载均衡    如果一个服务由多条服务器提供，需要把负载分配到不同的服务器处理，需要负载均衡。 upstream tomcat2 {    server 192.168.25.148:8081;    server 192.168.25.148:8082;  }可以根据服务器的实际情况调整服务器权重。权重越高分配的请求越多，权重越低，请求越少。默认是都是1 upstream tomcat2 {    server 192.168.25.148:8081;    server 192.168.25.148:8082 weight=2;    }</code></pre><h2 id="Nginx的高可用（了解）"><a href="#Nginx的高可用（了解）" class="headerlink" title="Nginx的高可用（了解）"></a>Nginx的高可用（了解）</h2><pre><code>要实现nginx的高可用，需要实现备份机。</code></pre><h3 id="什么是负载均衡高可用"><a href="#什么是负载均衡高可用" class="headerlink" title="什么是负载均衡高可用"></a>什么是负载均衡高可用</h3><pre><code>nginx作为负载均衡器，所有请求都到了nginx，可见nginx处于非常重点的位置，如果nginx服务器宕机后端web服务将无法提供服务，影响严重。为了屏蔽负载均衡服务器的宕机，需要建立一个备份机。主服务器和备份机上都运行高可用（High Availability）监控程序，通过传送诸如“I am alive”这样的信息来监控对方的运行状况。当备份机不能在一定的时间内收到这样的信息时，它就接管主服务器的服务IP并继续提供负载均衡服务；当备份管理器又从主管理器收到“I am alive”这样的信息时，它就释放服务IP地址，这样的主服务器就开始再次提供负载均衡服务。</code></pre><h3 id="keepalived-nginx实现主备"><a href="#keepalived-nginx实现主备" class="headerlink" title="keepalived+nginx实现主备"></a>keepalived+nginx实现主备</h3><h4 id="什么是keepalived"><a href="#什么是keepalived" class="headerlink" title="什么是keepalived"></a>什么是keepalived</h4><pre><code>keepalived是集群管理中保证集群高可用的一个服务软件，用来防止单点故障。 Keepalived的作用是检测web服务器的状态，如果有一台web服务器死机，或工作出现故障，Keepalived将检测到，并将有故障的web服务器从系统中剔除，当web服务器工作正常后Keepalived自动将web服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的web服务器。</code></pre><h4 id="keepalived工作原理"><a href="#keepalived工作原理" class="headerlink" title="keepalived工作原理"></a>keepalived工作原理</h4><pre><code>keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip（VIP = Virtual IP Address，虚拟IP地址，该路由器所在局域网内其他机器的默认路由为该vip），master会发组播，当backup收不到VRRP包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master。这样的话就可以保证路由器的高可用了。keepalived主要有三个模块，分别是core、check和VRRP。core模块为keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和解析。check负责健康检查，包括常见的各种检查方式。VRRP模块是来实现VRRP协议的。 详细参考：Keepalived权威指南中文.pdf</code></pre><h4 id="keepalived-nginx实现主备过程"><a href="#keepalived-nginx实现主备过程" class="headerlink" title="keepalived+nginx实现主备过程"></a>keepalived+nginx实现主备过程</h4><pre><code>初始状态</code></pre><p><img src="https://i.imgur.com/JusSTsw.png" alt="">    </p><pre><code>主机宕机</code></pre><p><img src="https://i.imgur.com/X6znO4I.png" alt=""></p><pre><code>主机恢复</code></pre><p><img src="https://i.imgur.com/0Cyz58m.png" alt=""></p><h4 id="高可用环境"><a href="#高可用环境" class="headerlink" title="高可用环境"></a>高可用环境</h4><pre><code>两台nginx，一主一备：192.168.101.3和192.168.101.4两台tomcat服务器：192.168.101.5、192.168.101.6</code></pre><h4 id="安装keepalived"><a href="#安装keepalived" class="headerlink" title="安装keepalived"></a>安装keepalived</h4><pre><code>分别在主备nginx上安装keepalived，参考“安装手册”进行安装：</code></pre><p>集群环境下会出现要求用户多次登录的情况。<br>解决方案：<br>1、配置tomcat集群。配置tomcatSession复制。节点数不要超过5个。<br>2、可以使用Session服务器，保存Session信息，使每个节点是无状态。需要模拟Session。</p><p>单点登录系统是使用redis模拟Session，实现Session的统一管理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;要求的安装环境&quot;&gt;&lt;a href=&quot;#要求的安装环境&quot; class=&quot;headerlink&quot; title=&quot;要求的安装环境&quot;&gt;&lt;/a&gt;要求的安装环境&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1、需要安装gcc的环境。yum install gcc-c++&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux下安装高版本的mysql</title>
    <link href="http://htuotuo.top/2018/03/04/linux%E5%AE%89%E8%A3%855.6%E7%89%88%E6%9C%AC%E4%BB%A5%E4%B8%8A%E7%9A%84mysql/"/>
    <id>http://htuotuo.top/2018/03/04/linux安装5.6版本以上的mysql/</id>
    <published>2018-03-04T07:33:42.572Z</published>
    <updated>2018-03-04T07:35:24.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1-Linux下安装mysql"><a href="#3-1-Linux下安装mysql" class="headerlink" title="3.1.Linux下安装mysql"></a>3.1.Linux下安装mysql</h2><pre><code>第一步：查看mysql是否安装。rpm -qa|grep mysql第二步：如果mysql的版本不是想要的版本。需要把mysql卸载。yum remove mysql mysql-server mysql-libs mysql-commonrm -rf /var/lib/mysql /etc/my.cnf第三步：安装mysql。需要使用yum命令安装。在安装mysql之前需要安装mysql的下载源。需要从oracle的官方网站下载。）下载mysql的源包。我们是centos6.4对应的rpm包为：mysql-community-release-el6-5.noarch.rpm2）安装mysql下载源：yum localinstall mysql-community-release-el6-5.noarch.rpm 3）在线安装mysql：yum install mysql-community-server第四步：启动mysqlservice mysqld start第五步：需要给root用户设置密码。/usr/bin/mysqladmin -u root password &apos;new-password&apos;　　// 为root账号设置密码第六步：远程连接授权。 ALL PRIVILEGES ON *.* TO &apos;myuser&apos;@&apos;%&apos; IDENTIFIED BY &apos;mypassword&apos; WITH GRANT OPTION;注意：&apos;myuser&apos;、&apos;mypassword&apos; 需要替换成实际的用户名和密码。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;3-1-Linux下安装mysql&quot;&gt;&lt;a href=&quot;#3-1-Linux下安装mysql&quot; class=&quot;headerlink&quot; title=&quot;3.1.Linux下安装mysql&quot;&gt;&lt;/a&gt;3.1.Linux下安装mysql&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;第一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux常见问题整合</title>
    <link href="http://htuotuo.top/2018/02/27/linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://htuotuo.top/2018/02/27/linux常见问题/</id>
    <published>2018-02-27T01:30:10.607Z</published>
    <updated>2018-04-08T08:07:01.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手动配置IP地址"><a href="#手动配置IP地址" class="headerlink" title="手动配置IP地址"></a>手动配置IP地址</h2><ul><li><p>1、自动获取IP地址<br>  虚拟机使用桥接模式，相当于连接到物理机的网络里，物理机网络有DHCP服务器自动分配IP地址。<br>  #dhclient 自动获取ip地址命令<br>  #ifconfig 查询系统里网卡信息，ip地址、MAC地址<br>  分配到ip地址后，用物理机进行ping ip地址，检测是否ping通。</p></li><li><p>2、手动设置ip地址</p><p>  如果虚拟机不能自动获取IP，只能手动配置，配置方法如下：<br>  输入命令<br>  #vi /etc/sysconfig/network-scripts/ifcfg-eth0</p><p>  编辑网卡的配置文件</p><p>  输入上述命令后回车，打开配置文件，使用方向键移动光标到最后一行，按字母键“O”，进入编辑模式，输入以下内容：<br>  IPADDR=192.168.25.10<br>  NETMASK=255.255.255.0<br>  GATEWAY=192.168.25.1<br>  另外光标移动到”ONBOOT=no”这一行，更改为ONBOOT=yes<br>  “BOOTPROTO=dhcp”，更改为BOOTPROTO=none<br>  完成后，按一下键盘左上角ESC键，输入:wq 在屏幕的左下方可以看到，输入回车保存配置文件。</p><p>  之后需要重启一下网络服务，命令为<br>  #service network restart</p><p>  网络重启后，eth0的ip就生效了，使用命令#ifconfigeth0 查看<br>  接下来检测配置的IP是否可以ping通，在物理机使用快捷键WINDOWS+R 打开运行框，输入命令cmd，输入ping 192.168.4.10 进行检测，ping通说明IP配置正确。</p><p>  备注：我所在的物理机网段为192.168.4.0 网段。大家做实验的时候根据自己的环境进行设定，保持虚拟机和物理机在同一网段即可。</p></li><li><p>3、使用NAT模式</p><p>  虚拟机网络连接使用NAT模式，物理机网络连接使用Vmnet8。<br>  虚拟机设置里面——网络适配器，网络连接选择NAT模式。<br>  虚拟机菜单栏—编辑—虚拟网络编辑器，选择Vmnet8 NAT模式，</p><p>  1．在最下面子网设置ip为192.168.20.0 子网掩码255.255.255.0<br>  2．NAT设置里面网关IP为192.168.20.2<br>  3．使用本地DHCP服务将IP地址分配给虚拟机不勾选</p><p>  设置完成后点击应用退出。</p><p>  CentOS 6.5 配置IP地址的三种方法</p><p>  物理机网络连接VMNet8 手动设置ip地址 192.168.20.1 子网掩码255.255.255.0<br>  网关和DNS地址为192.168.20.2（即虚拟机NAT的网关地址）</p><p>  编辑linux网卡eth0的配置文件<br>  #vi /etc/sysconfig/network-scripts/ifcfg-eth0</p><p>  输入上述命令后回车，打开配置文件，使用方向键移动光标到最后一行，按字母键“O”，进入编辑模式，输入以下内容：<br>  IPADDR=192.168.25.3<br>  NETMASK=255.255.255.0<br>  GATEWAY=192.168.25.2<br>  另外光标移动到”ONBOOT=no”这一行，更改为ONBOOT=yes<br>  “BOOTPROTO=dhcp”，更改为BOOTPROTO=none<br>  完成后，按一下键盘左上角ESC键，输入:wq 在屏幕的左下方可以看到，输入回车保存配置文件。</p><p>  设置DNS地址,运行命令<br>  #vi /etc/resolv.conf</p><p>  光标移动到空行，按“O”键，输入 nameserver 192.168.25.2 退出按ESC键，输入:wq 回车保存配置文件。<br>  重启网络服务<br>  #service network restart</p><p>  重启之后<br>  #ifconfig</p></li></ul><h2 id="unzip命令安装"><a href="#unzip命令安装" class="headerlink" title="unzip命令安装"></a>unzip命令安装</h2><pre><code>yum install zip unzip</code></pre><h2 id="解压缩和压缩"><a href="#解压缩和压缩" class="headerlink" title="解压缩和压缩"></a>解压缩和压缩</h2><pre><code>tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。常用参数：-c：创建一个新tar文件-v：显示运行过程的信息-f：指定文件名-z：调用gzip压缩命令进行压缩-t：查看压缩文件的内容-x：解开tar文件</code></pre><h2 id="jdk配置"><a href="#jdk配置" class="headerlink" title="jdk配置"></a>jdk配置</h2><pre><code>//打开/etc/profile文件# vim /etc/profile在文件末尾插入如下内容export JAVA_HOME=/home/soft/jdk1.8.0_111 export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH最后执行 source /etc/profile如果出现 -bash: /usr/local/jdk1.8.0_65/bin/java: Permission denied 这是因为访问权限不足执行以下命令：chmod 775 /home/jdk.bin</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code>不询问递归删除（慎用）rm -rf  a  ?  不询问递归删除rm -rf *   ?   删除所有文件</code></pre><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><pre><code>管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。示例ls --help | more  分页查询帮助信息ps –ef | grep java  查询名称中包含java的进程ifconfig | morecat index.html | moreps –ef | grep aio</code></pre><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><pre><code>entOS 6.5关闭防火墙步骤临时关闭命令：  service iptables stop 永久关闭防火墙：chkconfig iptables off开启改为 on两个命令同时运行，运行完成后查看防火墙关闭状态 service iptables status</code></pre><h2 id="出现centos-yum报错Loaded-plugins-fastestmirror"><a href="#出现centos-yum报错Loaded-plugins-fastestmirror" class="headerlink" title="出现centos yum报错Loaded plugins: fastestmirror"></a>出现centos yum报错Loaded plugins: fastestmirror</h2><pre><code>vi /etc/yum/pluginconf.d/fastestmirror.conf enabled = 0vi /etc/yum.confplugins=0yum clean dbcache</code></pre><h2 id="在使用yum时如果出现：Cannot-find-a-valid-baseurl-for-repo-base-7-x86-64"><a href="#在使用yum时如果出现：Cannot-find-a-valid-baseurl-for-repo-base-7-x86-64" class="headerlink" title="在使用yum时如果出现：Cannot find a valid baseurl for repo: base/7/x86_64"></a>在使用yum时如果出现：Cannot find a valid baseurl for repo: base/7/x86_64</h2><pre><code>这种情况通常是，是因为没有配置DNS服务器。解决方法：用VI编辑resolv.conf文件命令vi /etc/resolv.conf添加：nameserver 114.114.114.114    国内的wq保存退出即可</code></pre><h2 id="授予权限-c-权限不够"><a href="#授予权限-c-权限不够" class="headerlink" title="授予权限  ///**/c: 权限不够"></a>授予权限  /<strong>/</strong>/**/c: 权限不够</h2><pre><code>chmod +x /**/**/**/c</code></pre><h2 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h2><pre><code>Redis是c语言开发的。安装redis需要c语言的编译环境。如果没有gcc需要在线安装。先查询系统中是否有gcc命令，如果出现下面提示，则表示你的系统中已经安装好了gcc命令    [root@admin ~]# gccgcc: 没有输入文件[root@admin ~]# makemake: *** 没有指明目标并且找不到 makefile。 停止。安装：在线，必须配置的ip地址与虚拟机网关在统一个网段![](https://i.imgur.com/2aWQZVJ.png)yum install gcc-c++安装步骤：第一步：redis的源码包上传到linux系统。第二步：解压缩redis。第三步：编译。make 第四步：安装。make install PREFIX=/usr/local/redis</code></pre><h3 id="redis的启动："><a href="#redis的启动：" class="headerlink" title="redis的启动："></a>redis的启动：</h3><pre><code>前端启动：[root@localhost bin]# ./redis-server 后台启动：把/root/redis-3.0.0/redis.conf复制到/usr/local/redis/bin目录下[root@localhost redis-3.0.0]# cp redis.conf /usr/local/redis/bin/修改配置文件：[root@localhost bin]# ./redis-server redis.conf查看redis进程：[root@localhost bin]# ps aux|grep redisroot      5190  0.1  0.3  33936  1712 ?        Ssl  18:23   0:00 ./redis-server *:6379    root      5196  0.0  0.1   4356   728 pts/0    S+   18:24   0:00 grep redis[root@localhost bin]# </code></pre><h2 id="在使用yum命令进行安装时可能出现："><a href="#在使用yum命令进行安装时可能出现：" class="headerlink" title="在使用yum命令进行安装时可能出现："></a>在使用yum命令进行安装时可能出现：</h2><pre><code>Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=6&amp;arch=x86_64&amp;repo=os error was14: PYCURL ERROR 6 - &quot;Couldn&apos;t resolve host &apos;mirrorlist.centos.org&apos;&quot;Error: Cannot find a valid baseurl for repo: base错误，如果出现此错误：解决：解决方法：编辑vi resolv.conf文件，添加：nameserver 8.8.8.8 </code></pre><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><pre><code>cp(选项)(参数)选项-a：此参数的效果和同时指定&quot;-dpR&quot;参数相同；-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；-f：强行复制文件或目录，不论目标文件或目录是否已存在；-i：覆盖既有文件之前先询问用户；-l：对源文件建立硬连接，而非复制文件；-p：保留源文件或目录的属性；-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；-s：对源文件建立符号连接，而非复制文件；-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；-b：覆盖已存在的文件目标前将目标文件备份；-v：详细显示命令执行的操作。</code></pre><h2 id="文本编辑命令"><a href="#文本编辑命令" class="headerlink" title="文本编辑命令"></a>文本编辑命令</h2><h3 id="进入vi-vim的命令"><a href="#进入vi-vim的命令" class="headerlink" title="进入vi/vim的命令"></a>进入vi/vim的命令</h3><pre><code>vi/vim filename :打开或新建文件，并将光标置于第一行首vi/vim +n filename ：打开文件，并将光标置于第n行首vi/vim + filename ：打开文件，并将光标置于最后一行首vi/vim +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处vi/vim -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filenamevi/vim filename….filename ：打开多个文件，依次进行编辑</code></pre><h3 id="屏幕翻滚类命令"><a href="#屏幕翻滚类命令" class="headerlink" title="屏幕翻滚类命令"></a>屏幕翻滚类命令</h3><pre><code>Ctrl+u：向文件首翻半屏Ctrl+d：向文件尾翻半屏Ctrl+f：向文件尾翻一屏Ctrl＋b；向文件首翻一屏nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。</code></pre><h3 id="插入文本类命令"><a href="#插入文本类命令" class="headerlink" title="插入文本类命令"></a>插入文本类命令</h3><pre><code>i ：在光标前I ：在当前行首a：光标后A：在当前行尾o：在当前行之下新开一行O：在当前行之上新开一行r：替换当前字符R：替换当前字符及其后的字符，直至按ESC键s：从当前光标位置处开始，以输入的文本替代指定数目的字符S：删除指定数目的行，并以所输入文本代替之ncw或nCW：修改指定数目的字nCC：修改指定数目的行</code></pre><h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><pre><code>ndw或ndW：删除光标处开始及其后的n-1个字do：删至行首d$：删至行尾ndd：删除当前行及其后n-1行x或X：删除一个字符，x删除光标后的，而X删除光标前的Ctrl+u：删除输入方式下所输入的文本</code></pre><h3 id="搜索及替换命令"><a href="#搜索及替换命令" class="headerlink" title="搜索及替换命令"></a>搜索及替换命令</h3><pre><code>/pattern：从光标开始处向文件尾搜索pattern?pattern：从光标开始处向文件首搜索patternn：在同一方向重复上一次搜索命令N：在反方向上重复上一次搜索命令：s/p1/p2/g：将当前行中所有p1均用p2替代：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代：g/p1/s//p2/g：将文件中所有p1均用p2替换</code></pre><h3 id="选项设置"><a href="#选项设置" class="headerlink" title="选项设置"></a>选项设置</h3><pre><code>all：列出所有选项设置情况term：设置终端类型ignorance：在搜索中忽略大小写list：显示制表位(Ctrl+I)和行尾标志（$)number：显示行号report：显示由面向行的命令修改过的数目terse：显示简短的警告信息warn：在转到别的文件时若没保存当前文件则显示NO write信息nomagic：允许在搜索模式中，使用前面不带“\”的特殊字符nowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始mesg：允许vi显示其他用户用write写到自己终端上的信息</code></pre><h3 id="末行模式命令"><a href="#末行模式命令" class="headerlink" title="末行模式命令"></a>末行模式命令</h3><pre><code>：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下：n1,n2 d ：将n1行到n2行之间的内容删除：w ：保存当前文件：e filename：打开文件filename进行编辑：x：保存当前文件并退出：q：退出vi：q!：不保存文件并退出vi：!command：执行shell命令command：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入：r!command：将命令command的输出结果放到当前行 </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;手动配置IP地址&quot;&gt;&lt;a href=&quot;#手动配置IP地址&quot; class=&quot;headerlink&quot; title=&quot;手动配置IP地址&quot;&gt;&lt;/a&gt;手动配置IP地址&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、自动获取IP地址&lt;br&gt;  虚拟机使用桥接模式，相当于连接到物理机的网
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ActiveMQ队列</title>
    <link href="http://htuotuo.top/2018/02/25/ActiveMQ%E9%98%9F%E5%88%97/"/>
    <id>http://htuotuo.top/2018/02/25/ActiveMQ队列/</id>
    <published>2018-02-25T05:31:30.307Z</published>
    <updated>2018-02-26T03:32:37.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ActiveMQ-的作用分析"><a href="#ActiveMQ-的作用分析" class="headerlink" title="ActiveMQ 的作用分析"></a>ActiveMQ 的作用分析</h2><pre><code>ActiveMQ对列与webservice之间的区别：    相同：都可以用于不同系统之间的通讯    不同：ActiveMQ是异步，webservice是同步的         ActiveMQ有生产者和消费者，生产者生产，而消费者只负责监听消费，无需在发送响应之后等待，而webservice则需在发送响应后等待响应结果。</code></pre><h3 id="ActiveMQ-工作原理"><a href="#ActiveMQ-工作原理" class="headerlink" title="ActiveMQ 工作原理"></a>ActiveMQ 工作原理</h3><p><img src="https://i.imgur.com/yPDblmh.png" alt=""></p><pre><code>1、 解决服务之间耦合2、 使用消息队列，增加系统并发处理量ActiveMQ 应用场景分析1、 用户注册，重点用户信息数据库保存，发短信、发邮件，增加业务处理复杂度，这时候使用 MQ， 将发短信、发邮箱，通知 MQ，由另外服务平台完成2、 搜索平台、缓存平台查询数据，建立缓存、索引 ，不从数据库查询，从缓存或者索引库查询当增加、修改、删除数据时，发送消息给 MQ， 缓存平台、索引平台 从 MQ 获取到这个信息，更新缓存或者索引 </code></pre><h2 id="ActiveMQ-安装和使用"><a href="#ActiveMQ-安装和使用" class="headerlink" title="ActiveMQ 安装和使用"></a>ActiveMQ 安装和使用</h2><p><a href="http://activemq.apache.org/" target="_blank" rel="noopener">    官网： http://activemq.apache.org/</a></p><pre><code>进行 apache-activemq-5.14.0\bin\win64 目录 启动 activemq.bat 文件访问： http://localhost:8161/ 用户名和密码 都是 adminactiveMQ 使用的是标准生产者和消费者模型有两种数据结构 Queue、 Topic1、 Queue 队列 ，生产者生产了一个消息，只能由一个消费者进行消费2、 Topic 话题，生产者生产了一个消息，可以由多个消费者进行消费</code></pre><h2 id="使用-Java-程序操作-ActiveMQ（了解）"><a href="#使用-Java-程序操作-ActiveMQ（了解）" class="headerlink" title="使用 Java 程序操作 ActiveMQ（了解）"></a>使用 Java 程序操作 ActiveMQ（了解）</h2><pre><code>1、 开发 activeMQ 只需要导入 activemq-all-5.14.0.jar使用 maven 坐标2、 编写 MQ 消息生产者使用步骤：第一步：创建ConnectionFactory对象，需要指定服务端ip及端口号。第二步：使用ConnectionFactory对象创建一个Connection对象。第三步：开启连接，调用Connection对象的start方法。第四步：使用Connection对象创建一个Session对象。第五步：使用Session对象创建一个Destination对象（topic、queue），此处创建一个Topic对象。第六步：使用Session对象创建一个Producer对象。第七步：创建一个Message对象，创建一个TextMessage对象。第八步：使用Producer对象发送消息。第九步：关闭资源。</code></pre><p><img src="https://i.imgur.com/FVbY7sW.png" alt=""></p><pre><code>默认 tcp 连接 activeMQ 端口 61616 ！！！3、 编写 MQ 消费者代码消费者：接收消息。第一步：创建一个ConnectionFactory对象。第二步：从ConnectionFactory对象中获得一个Connection对象。第三步：开启连接。调用Connection对象的start方法。第四步：使用Connection对象创建一个Session对象。第五步：使用Session对象创建一个Destination对象。和发送端保持一致topic，并且话题的名称一致。第六步：使用Session对象创建一个Consumer对象。第七步：接收消息。第八步：打印消息。第九步：关闭资源a) 使用 MessageConsumer 完成消费</code></pre><p><img src="https://i.imgur.com/HJQg3sc.png" alt=""></p><pre><code>b) 使用监听器，监听消息的内容，进行消费</code></pre><p><img src="https://i.imgur.com/m0Kx8da.png" alt=""></p><p><strong>注意：在linux服务器中配置activeMQ访问页面如果出现503问题</strong></p><pre><code>解决方法：在linux中查看自己的主机名是否为localhost，如果不为localhost就需要使用 vim /ect/hosts 将自己主机名字添加在 localhost4这一行最后，添加自己的主机名保存即可</code></pre><h2 id="结合-spring-完成-ActiveMQ-编程"><a href="#结合-spring-完成-ActiveMQ-编程" class="headerlink" title="结合 spring 完成 ActiveMQ 编程"></a>结合 spring 完成 ActiveMQ 编程</h2><pre><code>1.在 activeMQ_spring 导入相关 jar 包，导入maven坐标</code></pre><p><img src="https://i.imgur.com/u7Jm2vX.png" alt=""></p><pre><code>2、 编写配置生产者配置 activemq 连接工厂使用此方式需要连接网络加载名称空间，一般使用原生的配置    </code></pre><p><img src="https://i.imgur.com/xExYQqE.png" alt=""></p><pre><code>配置 spring mq 管理工厂</code></pre><p><img src="https://i.imgur.com/5sCfpE0.png" alt=""></p><pre><code>配置 jmsTemplate 模板，有两种方式，使用一种即可</code></pre><p><img src="https://i.imgur.com/8M0tPru.png" alt=""></p><pre><code>完成代码</code></pre><p><img src="https://i.imgur.com/O0G8hz9.png" alt=""></p><pre><code>3、 编写消费者代码配置只扫描 consumer 包，topic跟queue队列相同，但topic是一对多mapMessage和textMessage mapMessage是key-value的形式</code></pre><p><img src="https://i.imgur.com/BJ6LfY5.png" alt=""></p><pre><code>配置 listener 监听器，在 applicationContext-mq-consumer.xml</code></pre><p><img src="https://i.imgur.com/BYc5Uql.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ActiveMQ-的作用分析&quot;&gt;&lt;a href=&quot;#ActiveMQ-的作用分析&quot; class=&quot;headerlink&quot; title=&quot;ActiveMQ 的作用分析&quot;&gt;&lt;/a&gt;ActiveMQ 的作用分析&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;ActiveMQ对列与web
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis缓存</title>
    <link href="http://htuotuo.top/2018/02/25/redis%E7%BC%93%E5%AD%98/"/>
    <id>http://htuotuo.top/2018/02/25/redis缓存/</id>
    <published>2018-02-25T05:31:00.876Z</published>
    <updated>2018-02-26T08:19:13.026Z</updated>
    
    <content type="html"><![CDATA[<pre><code>1、Redis服务器搭建2、向业务逻辑中添加缓存。3、使用redis做缓存4、缓存同步。5、Solr服务器安装</code></pre><h2 id="1-首页面的展示流程"><a href="#1-首页面的展示流程" class="headerlink" title="1.首页面的展示流程"></a>1.首页面的展示流程</h2><pre><code>首页是系统的门户，也就是系统的入口。所以首页的访问量是这个系统最大的。如果每次展示首页都从数据库中查询首页的内容信息，那么势必会对数据库造成很大的压力，所以需要使用缓存来减轻数据库压力。实现缓存的工具有很多，现在比较流行的是redis。</code></pre><h2 id="2-Redis的安装"><a href="#2-Redis的安装" class="headerlink" title="2.Redis的安装"></a>2.Redis的安装</h2><h3 id="1-Redis的安装"><a href="#1-Redis的安装" class="headerlink" title="1.Redis的安装"></a>1.Redis的安装</h3><pre><code>Redis是c语言开发的。安装redis需要c语言的编译环境。如果没有gcc需要在线安装。Yum install gcc-c++安装步骤：第一步：redis的源码包上传到linux系统。第二步：解压缩redis。第三步：编译。make 第四步：安装。make install PREFIX=/usr/local/redis</code></pre><h3 id="2-连接redis"><a href="#2-连接redis" class="headerlink" title="2.连接redis"></a>2.连接redis</h3><h4 id="redis的启动："><a href="#redis的启动：" class="headerlink" title="redis的启动："></a>redis的启动：</h4><pre><code>前端启动：[root@localhost bin]# ./redis-server 后台启动：把/root/redis-3.0.0/redis.conf复制到/usr/local/redis/bin目录下[root@localhost redis-3.0.0]# cp redis.conf /usr/local/redis/bin/修改配置文件：[root@localhost bin]# ./redis-server redis.conf查看redis进程：[root@localhost bin]# ps aux|grep redisroot      5190  0.1  0.3  33936  1712 ?        Ssl  18:23   0:00 ./redis-server *:6379    root      5196  0.0  0.1   4356   728 pts/0    S+   18:24   0:00 grep redis[root@localhost bin]# </code></pre><h4 id="Redis-cli"><a href="#Redis-cli" class="headerlink" title="Redis-cli"></a>Redis-cli</h4><pre><code>[root@localhost bin]# ./redis-cli 默认连接localhost运行在6379端口的redis服务。[root@localhost bin]# ./redis-cli -h 192.168.25.153 -p 6379-h：连接的服务器的地址-p：服务的端口号</code></pre><h2 id="3-Redis五种数据类型"><a href="#3-Redis五种数据类型" class="headerlink" title="3.Redis五种数据类型"></a>3.Redis五种数据类型</h2><pre><code>String：key-value（做缓存）Redis中所有数据都是key-value形式存储的,它都是字符串，命令不区分大小写，value    区分大小写，redis是单线程的，redis不适合保存内容大的数据（以k为单位）     get,set,incr 加一 （生成id）decr 减一Hash：key-fields-values（做缓存）相当于一个key对应一个map，map中也有key-value用hash对key进行分类 存值:hset key-filed-values  ,取值:hget key-filedhincrbodyList：有顺序可重复Set：无顺序，不能重复SortedSet（zset）：有顺序，不能重复</code></pre><h3 id="key命令"><a href="#key命令" class="headerlink" title="key命令"></a>key命令</h3><pre><code>设置key的过期时间Expire +key名字+ 时间（expire key second）Ttl key:查看key的有效期Persist key：清除key的过期时间。Key持久化</code></pre><h2 id="4-Redis的持久化"><a href="#4-Redis的持久化" class="headerlink" title="4.Redis的持久化"></a>4.Redis的持久化</h2><pre><code>Redis的所有数据都是保存在内存中Rdb （快照形式）：定期把内存中的数据保存在磁盘，内存中当前时刻（默认支持），丢失数据可能大aof形式：append only file。 把所有对数据库的操作（增删改操作的命令）保存到文件中。数据恢复时把所有的命令执行一遍即可</code></pre><h2 id="5-Redis集群的搭建"><a href="#5-Redis集群的搭建" class="headerlink" title="5.Redis集群的搭建"></a>5.Redis集群的搭建</h2><h3 id="redis-cluster架构图"><a href="#redis-cluster架构图" class="headerlink" title="redis-cluster架构图"></a>redis-cluster架构图</h3><p><img src="https://i.imgur.com/vUAokJA.png" alt=""></p><pre><code>架构细节:(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可(4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;valueRedis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点</code></pre><h3 id="Redis集群的搭建"><a href="#Redis集群的搭建" class="headerlink" title="Redis集群的搭建"></a>Redis集群的搭建</h3><pre><code>Redis集群中至少有3个节点，要保证集群的高可用，需要每个节点有一个备份机，redis集群至少要6台服务机</code></pre><h4 id="集群搭建环境"><a href="#集群搭建环境" class="headerlink" title="集群搭建环境"></a>集群搭建环境</h4><pre><code>1、使用ruby脚本搭建集群。需要ruby的运行环境。安装rubyyum install rubyyum install rubygems2、安装ruby脚本运行使用的包。[root@localhost ~]# gem install redis-3.0.0.gem Successfully installed redis-3.0.01 gem installedInstalling ri documentation for redis-3.0.0...Installing RDoc documentation for redis-3.0.0...[root@localhost ~]# [root@localhost ~]# cd redis-3.0.0/src[root@localhost src]# ll *.rb-rwxrwxr-x. 1 root root 48141 Apr  1  2015 redis-trib.rb5.2.2.搭建步骤需要6台redis服务器。搭建伪分布式。需要6个redis实例。需要运行在不同的端口7001-7006第一步：创建6个redis实例，每个实例运行在不同的端口。需要修改redis.conf配置文件。配置文件中还需要把cluster-enabled yes前的注释去掉。</code></pre><p><img src="https://i.imgur.com/R9unXjI.png" alt="">        </p><pre><code>第二步：启动每个redis实例。第三步：使用ruby脚本搭建集群。将*.rb 文件复制到redis-cluster 集群文件中./redis-trib.rb create --replicas 1 192.168.25.132:7001 192.168.25.132:7002 192.168.25.132:7003 192.168.25.132:7004 192.168.25.132:7005  192.168.25.132:7006如果是安装在同一个服务其中使用./redis-trib.rb create --replicas 1 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005  127.0.0.1:7006创建关闭集群的脚本：[root@localhost redis-cluster]# vim shutdow-all.shredis01/redis-cli -p 7001 shutdownredis01/redis-cli -p 7002 shutdownredis01/redis-cli -p 7003 shutdownredis01/redis-cli -p 7004 shutdownredis01/redis-cli -p 7005 shutdownredis01/redis-cli -p 7006 shutdown[root@localhost redis-cluster]# chmod u+x shutdow-all.sh [root@localhost redis-cluster]# ./redis-trib.rb create --replicas 1 192.168.25.153:7001 192.168.25.153:7002 192.168.25.153:7003 192.168.25.153:7004 192.168.25.153:7005  192.168.25.153:7006&gt;&gt;&gt; Creating clusterConnecting to node 192.168.25.153:7001: OKConnecting to node 192.168.25.153:7002: OKConnecting to node 192.168.25.153:7003: OKConnecting to node 192.168.25.153:7004: OKConnecting to node 192.168.25.153:7005: OKConnecting to node 192.168.25.153:7006: OK&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Using 3 masters:192.168.25.153:7001192.168.25.153:7002192.168.25.153:7003Adding replica 192.168.25.153:7004 to 192.168.25.153:7001Adding replica 192.168.25.153:7005 to 192.168.25.153:7002Adding replica 192.168.25.153:7006 to 192.168.25.153:7003M: 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3 192.168.25.153:7001   slots:0-5460 (5461 slots) masterM: 8cd93a9a943b4ef851af6a03edd699a6061ace01 192.168.25.153:7002   slots:5461-10922 (5462 slots) masterM: 2935007902d83f20b1253d7f43dae32aab9744e6 192.168.25.153:7003   slots:10923-16383 (5461 slots) masterS: 74f9d9706f848471583929fc8bbde3c8e99e211b 192.168.25.153:7004   replicates 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3S: 42cc9e25ebb19dda92591364c1df4b3a518b795b 192.168.25.153:7005   replicates 8cd93a9a943b4ef851af6a03edd699a6061ace01S: 8b1b11d509d29659c2831e7a9f6469c060dfcd39 192.168.25.153:7006   replicates 2935007902d83f20b1253d7f43dae32aab9744e6Can I set the above configuration? (type &apos;yes&apos; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join.....&gt;&gt;&gt; Performing Cluster Check (using node 192.168.25.153:7001)M: 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3 192.168.25.153:7001   slots:0-5460 (5461 slots) masterM: 8cd93a9a943b4ef851af6a03edd699a6061ace01 192.168.25.153:7002   slots:5461-10922 (5462 slots) masterM: 2935007902d83f20b1253d7f43dae32aab9744e6 192.168.25.153:7003   slots:10923-16383 (5461 slots) masterM: 74f9d9706f848471583929fc8bbde3c8e99e211b 192.168.25.153:7004   slots: (0 slots) master   replicates 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3M: 42cc9e25ebb19dda92591364c1df4b3a518b795b 192.168.25.153:7005   slots: (0 slots) master   replicates 8cd93a9a943b4ef851af6a03edd699a6061ace01M: 8b1b11d509d29659c2831e7a9f6469c060dfcd39 192.168.25.153:7006   slots: (0 slots) master   replicates 2935007902d83f20b1253d7f43dae32aab9744e6[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.[root@localhost redis-cluster]# </code></pre><h4 id="集群的使用方法"><a href="#集群的使用方法" class="headerlink" title="集群的使用方法"></a>集群的使用方法</h4><pre><code>Redis-cli连接集群。[root@localhost redis-cluster]# redis01/redis-cli -p 7002 -c-c：代表连接的是redis集群</code></pre><h2 id="6-Jedis"><a href="#6-Jedis" class="headerlink" title="6.Jedis"></a>6.Jedis</h2><pre><code>需要把jedis依赖的jar包添加到工程中。Maven工程中需要把jedis的坐标添加到依赖。推荐添加到服务层。Taotao-content-Service工程中。</code></pre><h3 id="6-1-连接单机版"><a href="#6-1-连接单机版" class="headerlink" title="6.1.连接单机版"></a>6.1.连接单机版</h3><pre><code>第一步：创建一个Jedis对象。需要指定服务端的ip及端口。第二步：使用Jedis对象操作数据库，每个redis命令对应一个方法。第三步：打印结果。第四步：关闭Jedis@Test    public void testJedis() throws Exception {        // 第一步：创建一个Jedis对象。需要指定服务端的ip及端口。        Jedis jedis = new Jedis(&quot;192.168.25.153&quot;, 6379);        // 第二步：使用Jedis对象操作数据库，每个redis命令对应一个方法。        String result = jedis.get(&quot;hello&quot;);        // 第三步：打印结果。        System.out.println(result);        // 第四步：关闭Jedis        jedis.close();    }</code></pre><h3 id="6-2-连接单机版使用连接池"><a href="#6-2-连接单机版使用连接池" class="headerlink" title="6.2.连接单机版使用连接池"></a>6.2.连接单机版使用连接池</h3><pre><code>第一步：创建一个JedisPool对象。需要指定服务端的ip及端口。第二步：从JedisPool中获得Jedis对象。第三步：使用Jedis操作redis服务器。第四步：操作完毕后关闭jedis对象，连接池回收资源。第五步：关闭JedisPool对象。@Test    public void testJedisPool() throws Exception {        // 第一步：创建一个JedisPool对象。需要指定服务端的ip及端口。        JedisPool jedisPool = new JedisPool(&quot;192.168.25.153&quot;, 6379);        // 第二步：从JedisPool中获得Jedis对象。        Jedis jedis = jedisPool.getResource();        // 第三步：使用Jedis操作redis服务器。        jedis.set(&quot;jedis&quot;, &quot;test&quot;);        String result = jedis.get(&quot;jedis&quot;);        System.out.println(result);        // 第四步：操作完毕后关闭jedis对象，连接池回收资源。        jedis.close();        // 第五步：关闭JedisPool对象。        jedisPool.close();    }</code></pre><h3 id="6-3-连接集群版"><a href="#6-3-连接集群版" class="headerlink" title="6.3.连接集群版"></a>6.3.连接集群版</h3><pre><code>第一步：使用JedisCluster对象。需要一个Set&lt;HostAndPort&gt;参数。Redis节点的列表。第二步：直接使用JedisCluster对象操作redis。在系统中单例存在。第三步：打印结果第四步：系统关闭前，关闭JedisCluster对象。@Test    public void testJedisCluster() throws Exception {        // 第一步：使用JedisCluster对象。需要一个Set&lt;HostAndPort&gt;参数。Redis节点的列表。        Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;();        nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7001));        nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7002));        nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7003));        nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7004));        nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7005));        nodes.add(new HostAndPort(&quot;192.168.25.153&quot;, 7006));        JedisCluster jedisCluster = new JedisCluster(nodes);        // 第二步：直接使用JedisCluster对象操作redis。在系统中单例存在。        jedisCluster.set(&quot;hello&quot;, &quot;100&quot;);        String result = jedisCluster.get(&quot;hello&quot;);        // 第三步：打印结果        System.out.println(result);        // 第四步：系统关闭前，关闭JedisCluster对象。        jedisCluster.close();    }</code></pre><h2 id="7-向业务逻辑中添加缓存"><a href="#7-向业务逻辑中添加缓存" class="headerlink" title="7.向业务逻辑中添加缓存"></a>7.向业务逻辑中添加缓存</h2><h3 id="接口封装"><a href="#接口封装" class="headerlink" title="接口封装"></a>接口封装</h3><pre><code>常用的操作redis的方法提取出一个接口，分别对应单机版和集群版创建两个实现类。</code></pre><h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h4><pre><code>public interface JedisClient {    String set(String key, String value);    String get(String key);    Boolean exists(String key);    Long expire(String key, int seconds);    Long ttl(String key);    Long incr(String key);    Long hset(String key, String field, String value);    String hget(String key, String field);    Long hdel(String key, String... field);}</code></pre><h4 id="单机版实现类"><a href="#单机版实现类" class="headerlink" title="单机版实现类"></a>单机版实现类</h4><pre><code>public class JedisClientPool implements JedisClient {    @Autowired    private JedisPool jedisPool;    @Override    public String set(String key, String value) {        Jedis jedis = jedisPool.getResource();        String result = jedis.set(key, value);        jedis.close();        return result;    }    @Override    public String get(String key) {        Jedis jedis = jedisPool.getResource();        String result = jedis.get(key);        jedis.close();        return result;    }    @Override    public Boolean exists(String key) {        Jedis jedis = jedisPool.getResource();        Boolean result = jedis.exists(key);        jedis.close();        return result;    }    @Override    public Long expire(String key, int seconds) {        Jedis jedis = jedisPool.getResource();        Long result = jedis.expire(key, seconds);        jedis.close();        return result;    }    @Override    public Long ttl(String key) {        Jedis jedis = jedisPool.getResource();        Long result = jedis.ttl(key);        jedis.close();        return result;    }    @Override    public Long incr(String key) {        Jedis jedis = jedisPool.getResource();        Long result = jedis.incr(key);        jedis.close();        return result;    }    @Override    public Long hset(String key, String field, String value) {        Jedis jedis = jedisPool.getResource();        Long result = jedis.hset(key, field, value);        jedis.close();        return result;    }    @Override    public String hget(String key, String field) {        Jedis jedis = jedisPool.getResource();        String result = jedis.hget(key, field);        jedis.close();        return result;    }    @Override    public Long hdel(String key, String... field) {        Jedis jedis = jedisPool.getResource();        Long result = jedis.hdel(key, field);        jedis.close();        return result;    }}配置：applicationContext-redis.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans4.2.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context4.2.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx4.2.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util4.2.xsd&quot;&gt;    &lt;!-- 配置单机版的连接 --&gt;    &lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot;&gt;        &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;        &lt;constructor-arg name=&quot;port&quot; value=&quot;6379&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;bean id=&quot;jedisClientPool&quot; class=&quot;com.taotao.jedis.JedisClientPool&quot;/&gt;&lt;/beans&gt;</code></pre><h4 id="集群版实现类"><a href="#集群版实现类" class="headerlink" title="集群版实现类"></a>集群版实现类</h4><pre><code>package com.xxx.jedis;import org.springframework.beans.factory.annotation.Autowired;import redis.clients.jedis.JedisCluster;public class JedisClientCluster implements JedisClient {    @Autowired    private JedisCluster jedisCluster;    @Override    public String set(String key, String value) {        return jedisCluster.set(key, value);    }    @Override    public String get(String key) {        return jedisCluster.get(key);    }    @Override    public Boolean exists(String key) {        return jedisCluster.exists(key);    }    @Override    public Long expire(String key, int seconds) {        return jedisCluster.expire(key, seconds);    }    @Override    public Long ttl(String key) {        return jedisCluster.ttl(key);    }    @Override    public Long incr(String key) {        return jedisCluster.incr(key);    }    @Override    public Long hset(String key, String field, String value) {        return jedisCluster.hset(key, field, value);    }    @Override    public String hget(String key, String field) {        return jedisCluster.hget(key, field);    }    @Override    public Long hdel(String key, String... field) {        return jedisCluster.hdel(key, field);    }}Spring的配置：&lt;!-- 集群版的配置 --&gt;    &lt;bean id=&quot;jedisCluster&quot; class=&quot;redis.clients.jedis.JedisCluster&quot;&gt;        &lt;constructor-arg&gt;            &lt;set&gt;                &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;7001&quot;&gt;&lt;/constructor-arg&gt;                &lt;/bean&gt;                &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;7002&quot;&gt;&lt;/constructor-arg&gt;                &lt;/bean&gt;                &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;7003&quot;&gt;&lt;/constructor-arg&gt;                &lt;/bean&gt;                &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;7004&quot;&gt;&lt;/constructor-arg&gt;                &lt;/bean&gt;                &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;7005&quot;&gt;&lt;/constructor-arg&gt;                &lt;/bean&gt;                &lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.25.153&quot;&gt;&lt;/constructor-arg&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;7006&quot;&gt;&lt;/constructor-arg&gt;                &lt;/bean&gt;            &lt;/set&gt;        &lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;bean id=&quot;jedisClientCluster&quot; class=&quot;com.taotao.jedis.JedisClientCluster&quot;/&gt;注意：单机版和集群版不能共存，使用单机版时注释集群版的配置。使用集群版，把单机版注释。</code></pre><h3 id="封装代码测试"><a href="#封装代码测试" class="headerlink" title="封装代码测试"></a>封装代码测试</h3><pre><code>@Test    public void testJedisClient() throws Exception {        //初始化Spring容器        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext-*.xml&quot;);        //从容器中获得JedisClient对象        JedisClient jedisClient = applicationContext.getBean(JedisClient.class);        jedisClient.set(&quot;first&quot;, &quot;100&quot;);        String result = jedisClient.get(&quot;first&quot;);        System.out.println(result);    }</code></pre><h3 id="添加缓存"><a href="#添加缓存" class="headerlink" title="添加缓存"></a>添加缓存</h3><h4 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h4><pre><code>查询内容列表时添加缓存。1、查询数据库之前先查询缓存。2、查询到结果，直接响应结果。3、查询不到，缓存中没有需要查询数据库。4、把查询结果添加到缓存中。5、返回结果。向redis中添加缓存：Key：cidValue：内容列表。需要把java对象转换成json。使用hash对key进行归类。HASH_KEY:HASH            |--KEY:VALUE            |--KEY:VALUE            |--KEY:VALUE            |--KEY:VALUE注意：添加缓存不能影响正常业务逻辑。</code></pre><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>@Override    public List&lt;TbContent&gt; getContentList(long cid) {        //查询缓存        try {            String json = jedisClient.hget(CONTENT_KEY, cid + &quot;&quot;);            //判断json是否为空            if (StringUtils.isNotBlank(json)) {                //把json转换成list                List&lt;TbContent&gt; list = JsonUtils.jsonToList(json, TbContent.class);                return list;            }        } catch (Exception e) {            e.printStackTrace();        }        //根据cid查询内容列表        TbContentExample example = new TbContentExample();        //设置查询条件        Criteria criteria = example.createCriteria();        criteria.andCategoryIdEqualTo(cid);        //执行查询        List&lt;TbContent&gt; list = contentMapper.selectByExample(example);        //向缓存中添加数据        try {            jedisClient.hset(CONTENT_KEY, cid + &quot;&quot;, JsonUtils.objectToJson(list));        } catch (Exception e) {            e.printStackTrace();        }        return list;    }</code></pre><h3 id="缓存同步"><a href="#缓存同步" class="headerlink" title="缓存同步"></a>缓存同步</h3><pre><code>对内容信息做增删改操作后只需要把对应缓存删除即可。可以根据cid删除。@Override    public TaotaoResult addContent(TbContent content) {        //补全属性        content.setCreated(new Date());        content.setUpdated(new Date());        //插入数据        contentMapper.insert(content);        //缓存同步        jedisClient.hdel(CONTENT_KEY, content.getCategoryId().toString());        return TaotaoResult.ok();    }</code></pre><h2 id="8-搜索工程搭建"><a href="#8-搜索工程搭建" class="headerlink" title="8.搜索工程搭建"></a>8.搜索工程搭建</h2><pre><code>要实现搜索功能，需要搭建solr服务、搜索服务工程、搜索系统</code></pre><h3 id="Solr服务搭建"><a href="#Solr服务搭建" class="headerlink" title="Solr服务搭建"></a>Solr服务搭建</h3><h4 id="Solr的环境"><a href="#Solr的环境" class="headerlink" title="Solr的环境"></a>Solr的环境</h4><pre><code>Solr是java开发。需要安装jdk。安装环境Linux。需要安装Tomcat。</code></pre><h4 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><pre><code>第一步：把solr 的压缩包上传到Linux系统第二步：解压solr。第三步：安装Tomcat，解压缩即可。第四步：把solr部署到Tomcat下。第五步：解压缩war包。启动Tomcat解压。第六步：把/root/solr-4.10.3/example/lib/ext目录下的所有的jar包，添加到solr工程中。[root@localhost ext]# pwd/root/solr-4.10.3/example/lib/ext[root@localhost ext]# cp * /usr/local/solr/tomcat/webapps/solr/WEB-INF/lib/第七步：创建一个solrhome。/example/solr目录就是一个solrhome。复制此目录到/usr/local/solr/solrhome[root@localhost example]# pwd/root/solr-4.10.3/example[root@localhost example]# cp -r solr /usr/local/solr/solrhome[root@localhost example]# 第八步：关联solr及solrhome。需要修改solr工程的web.xml文件。第九步：启动Tomcathttp://192.168.25.154:8080/solr/和windows下的配置完全一样。</code></pre><h4 id="Solr的使用"><a href="#Solr的使用" class="headerlink" title="Solr的使用"></a>Solr的使用</h4><pre><code>添加文档必须有id域，其他域 必须在solr的schema.xml中定义。</code></pre><h3 id="配置业务域"><a href="#配置业务域" class="headerlink" title="配置业务域"></a>配置业务域</h3><pre><code>schema.xml中定义，这里定义的是自己需要进行索引的字段1、商品Id2、商品标题3、商品卖点4、商品价格5、商品图片6、分类名称7、商品描述创建对应的业务域。需要制定中文分析器。创建步骤：第一步：把中文分析器添加到工程中。1、把IKAnalyzer2012FF_u1.jar添加到solr工程的lib目录下2、把扩展词典、配置文件放到solr工程的WEB-INF/classes目录下。第二步：配置一个FieldType，制定使用IKAnalyzer修改schema.xml文件修改Solr的schema.xml文件，添加FieldType：&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;  &lt;analyzer class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;&lt;/fieldType&gt;第三步：配置业务域，type制定使用自定义的FieldType。设置业务系统Field&lt;field name=&quot;item_title&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_sell_point&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_price&quot;  type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_image&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_category_name&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_desc&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; /&gt;&lt;field name=&quot;item_keywords&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt;&lt;copyField source=&quot;item_title&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_sell_point&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_category_name&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_desc&quot; dest=&quot;item_keywords&quot;/&gt;第四步：重启tomcat</code></pre><h3 id="搜索服务工程搭建"><a href="#搜索服务工程搭建" class="headerlink" title="搜索服务工程搭建"></a>搜索服务工程搭建</h3><pre><code>可以参考taotao-manager创建。项目名-search（聚合工程pom）|--项目名-search-interface（jar）|--项目名-search-Service（war）</code></pre><h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><pre><code>怎么将二维表的转为redis的String 类型数据使用：的格式进行转换：表名：主键id：字段名：字段内容    </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;1、Redis服务器搭建
2、向业务逻辑中添加缓存。
3、使用redis做缓存
4、缓存同步。
5、Solr服务器安装
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;1-首页面的展示流程&quot;&gt;&lt;a href=&quot;#1-首页面的展示流程&quot; class=&quot;headerl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webservice的Restful风格</title>
    <link href="http://htuotuo.top/2018/02/24/webservice%E7%9A%84Restful%E9%A3%8E%E6%A0%BC/"/>
    <id>http://htuotuo.top/2018/02/24/webservice的Restful风格/</id>
    <published>2018-02-24T12:54:44.032Z</published>
    <updated>2018-02-25T05:28:01.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的xml（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。用于多系统之间的交互</p><h2 id="什么是Web-Service"><a href="#什么是Web-Service" class="headerlink" title="什么是Web Service"></a>什么是Web Service</h2><pre><code>Web service 就是一个应用程序，它向外界暴露出一个能够通过Web进行调用的APIWeb services是建立可互操作的分布式应用程序的新平台Web service平台是一套标准，它定义了应用程序如何在Web上实现互操作性。你可以用任何你喜欢的语言，在任何你喜欢的平台上写Web service ，只要我们可以通过Web service标准对这些服务进行查询和访问。</code></pre><h2 id="JAX-WS-独立服务使用-了解"><a href="#JAX-WS-独立服务使用-了解" class="headerlink" title="JAX-WS 独立服务使用(了解)"></a>JAX-WS 独立服务使用(了解)</h2><h2 id="JAX-RS-独立服务使用-了解"><a href="#JAX-RS-独立服务使用-了解" class="headerlink" title="JAX-RS 独立服务使用(了解)"></a>JAX-RS 独立服务使用(了解)</h2><pre><code>restful风格好处：基于这种风格架构，软件编写可以更简洁基于 HTTP 协议， 支持多种消息格式，比如 XML 、 JSON更易于实现缓存机制（第一次访问资源 缓存，第二次访问资源，返回 304 客户端调用本地）</code></pre><p><img src="https://i.imgur.com/vNjcvZk.png" alt=""></p><pre><code>以上定义的只是一种风格不是一种固定格式POST 请求方式访问 保存操作PUT 请求方式访问 修改操作GET 请求方式访问 查询操作DELETE 请求方式访问 删除操作</code></pre><h3 id="JAX-RS的使用步骤："><a href="#JAX-RS的使用步骤：" class="headerlink" title="JAX-RS的使用步骤："></a>JAX-RS的使用步骤：</h3><h4 id="1-基于-maven-导入坐标"><a href="#1-基于-maven-导入坐标" class="headerlink" title="1.基于 maven 导入坐标"></a>1.基于 maven 导入坐标</h4><h4 id="2、-导入实体类"><a href="#2、-导入实体类" class="headerlink" title="2、 导入实体类"></a>2、 导入实体类</h4><p><img src="https://i.imgur.com/8v8wmLD.png" alt=""></p><pre><code>在实体类上一定要加入@XmlRootElement(name=&quot;User&quot;);@XmlRootElement 指定序列化（转换 XML、 JSON） 对象名字</code></pre><p><img src="https://i.imgur.com/4bAjpjN.png" alt=""></p><pre><code>如果没加@XmlRootElement(name=&quot;User&quot;)注解就会出现以下错误：</code></pre><p><img src="https://i.imgur.com/WcajaeP.png" alt=""></p><pre><code>如果该类使用了泛型还需添加另一个注解@XmlSeeAlso({ xxx.class })中括号中添加为泛型的类型的类</code></pre><h4 id="3、-编写业务类"><a href="#3、-编写业务类" class="headerlink" title="3、 编写业务类"></a>3、 编写业务类</h4><p><img src="https://i.imgur.com/KDUQtQi.png" alt=""></p><pre><code>第一种 @Path 服务访问资源路径如果访问 saveUser 方法 /userService/user第二种 @Produces 生成（方法返回值） @Consumes 消费 （方法参数）@Consumes 指定能够处理客户端传递过来数据格式@Produces 指定能否生成哪种格式数据返回给客户端第三种 @GET 查询 @PUT 修改 @POST 增加 @DELETE 删除</code></pre><h4 id="4、-发布服务（单独发布）"><a href="#4、-发布服务（单独发布）" class="headerlink" title="4、 发布服务（单独发布）"></a>4、 发布服务（单独发布）</h4><p><img src="https://i.imgur.com/gLjghe3.png" alt=""></p><h4 id="5、-客户端程序的编写"><a href="#5、-客户端程序的编写" class="headerlink" title="5、 客户端程序的编写"></a>5、 客户端程序的编写</h4><pre><code>有两种做法1） 使用 http client 工具 ，需要自己对 HTTP 协议内容进行定制和解析2） WebClient 工具类使用 （CXF 自带）</code></pre><p><img src="https://i.imgur.com/obDga9R.png" alt=""></p><pre><code>JAX-RS 如何传输 JSON 格式的数据 ？如果指定客户端要获取 json 内容错误： Caused by: javax.ws.rs.ProcessingException: No message body writer has been foundfor class cn.itcast.cxf.domain.User, ContentType: application/json解决： 在项目引入 json 转换器</code></pre><p><img src="https://i.imgur.com/2xeUyDM.png" alt=""></p><h2 id="JAX-RS-和-Spring-整合开发使用（重点）"><a href="#JAX-RS-和-Spring-整合开发使用（重点）" class="headerlink" title="JAX-RS 和 Spring 整合开发使用（重点）"></a>JAX-RS 和 Spring 整合开发使用（重点）</h2><h3 id="1-maven坐标引入"><a href="#1-maven坐标引入" class="headerlink" title="1.maven坐标引入"></a>1.maven坐标引入</h3><p><img src="https://i.imgur.com/cEJPXpb.png" alt=""></p><p><img src="https://i.imgur.com/MiWJvkz.png" alt=""></p><pre><code>导入 web.xml，在web.xml中需要添加一个webservice配置</code></pre><p><img src="https://i.imgur.com/2ISJ2XP.png" alt=""></p><h3 id="2、-导入实体类和-Service"><a href="#2、-导入实体类和-Service" class="headerlink" title="2、 导入实体类和 Service"></a>2、 导入实体类和 Service</h3><h3 id="3、-在-spring-配置发布-rs-服务"><a href="#3、-在-spring-配置发布-rs-服务" class="headerlink" title="3、 在 spring 配置发布 rs 服务"></a>3、 在 spring 配置发布 rs 服务</h3><pre><code>引入名称空间 xmlns:jaxrs=&quot;http://cxf.apache.org/jaxrs&quot;http://cxf.apache.org/jaxrs http://cxf.apache.org/schemas/jaxrs.xsd最终访问资源服务路径服务器根目录地址 + web.xml 配置 + applicationContext.xml address 配置 + 类@Path +方法 @Path</code></pre><p><img src="https://i.imgur.com/P3AgeTW.png" alt=""></p><pre><code>applicationContext-webservice.xml服务端配置</code></pre><p><img src="https://i.imgur.com/SkQOoW1.png" alt=""></p><h3 id="4、-编写客户端代码-类似独立服务客户端代码"><a href="#4、-编写客户端代码-类似独立服务客户端代码" class="headerlink" title="4、 编写客户端代码 类似独立服务客户端代码"></a>4、 编写客户端代码 类似独立服务客户端代码</h3><pre><code>WebClient 工具实现，客户端不需要进行配置直接使用webclient。create方法进行调用，访问路径参照：服务器根目录地址 + web.xml 配置 + applicationContext.xml address 配置 + 类@Path +方法 @Path// 使用webClient调用 webService接口Collection&lt;? extends Customer&gt; collection = WebClient        .create(&quot;http://localhost:9002/crm_management/services/userservice/xxx&quot;)        .accept(MediaType.APPLICATION_JSON)        .getCollection(Customer.class);如果有返回值，返回的是结果集就使用getConllection获取，单个结果就直接使用getaccept为接收返回值</code></pre><p>注意：在webservice中服务方法参数有两个注解：</p><p>@pathParam 如果在方法参数中使用该配置，在客户端访问路径/后面直接拼接参数</p><p><img src="https://i.imgur.com/fb7DKES.png" alt=""></p><p>@queryparam 如果在方法参数中使用该配置，在客户端访问路径必须使用？&amp;的方式进行参数的拼接</p><p><img src="https://i.imgur.com/ZkylBdF.png" alt=""></p><h2 id="在用于分布式系统间的通讯，还有一个dubbo（个人觉得dubbo更好使用）"><a href="#在用于分布式系统间的通讯，还有一个dubbo（个人觉得dubbo更好使用）" class="headerlink" title="在用于分布式系统间的通讯，还有一个dubbo（个人觉得dubbo更好使用）"></a>在用于分布式系统间的通讯，还有一个dubbo（个人觉得dubbo更好使用）</h2><h3 id="1-什么是dubbo"><a href="#1-什么是dubbo" class="headerlink" title="1.什么是dubbo"></a>1.什么是dubbo</h3><pre><code>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</code></pre><ul><li><p>单一应用架构 </p><ul><li>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。<br>此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。</li></ul></li><li><p>垂直应用架构 </p><ul><li>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。<br>此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</li></ul></li><li><p>分布式服务架构 </p><ul><li>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。</li></ul></li><li><p>流动计算架构 </p><ul><li>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。<br><strong>Dubbo就是资源调度和治理中心的管理工具。</strong></li></ul></li></ul><h3 id="2-Dubbo的架构"><a href="#2-Dubbo的架构" class="headerlink" title="2.Dubbo的架构"></a>2.Dubbo的架构</h3><p><img src="https://i.imgur.com/Qr5lJBC.png" alt=""></p><ul><li><p>节点角色说明：</p><ol><li>Provider: 暴露服务的服务提供方。</li><li>Consumer: 调用远程服务的服务消费方。</li><li>Registry: 服务注册与发现的注册中心。</li><li>Monitor: 统计服务的调用次调和调用时间的监控中心。</li><li>Container: 服务运行容器。</li></ol></li><li><p>调用关系说明：</p><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol></li></ul><h3 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3.使用方法"></a>3.使用方法</h3><pre><code>1.Spring配置Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。单一工程中spring的配置&lt;bean id=&quot;xxxService&quot; class=&quot;com.xxx.XxxServiceImpl&quot; /&gt;&lt;bean id=&quot;xxxAction&quot; class=&quot;com.xxx.XxxAction&quot;&gt;    &lt;property name=&quot;xxxService&quot; ref=&quot;xxxService&quot; /&gt;&lt;/bean&gt;远程服务：在本地服务的基础上，只需做简单配置，即可完成远程化：将上面的local.xml配置拆分成两份，将服务定义部分放在服务提供方remote-provider.xml，将服务引用部分放在服务消费方remote-consumer.xml。并在提供方增加暴露服务配置&lt;dubbo:service&gt;，在消费方增加引用服务配置&lt;dubbo:reference&gt;。发布服务：&lt;!-- 和本地服务一样实现远程服务 --&gt;&lt;bean id=&quot;xxxService&quot; class=&quot;com.xxx.XxxServiceImpl&quot; /&gt;&lt;!-- 增加暴露远程服务配置 --&gt;&lt;dubbo:service interface=&quot;com.xxx.XxxService&quot; ref=&quot;xxxService&quot; /&gt;调用服务：&lt;!-- 增加引用远程服务配置 --&gt;&lt;dubbo:reference id=&quot;xxxService&quot; interface=&quot;com.xxx.XxxService&quot; /&gt;&lt;!-- 和本地服务一样使用远程服务 --&gt;&lt;bean id=&quot;xxxAction&quot; class=&quot;com.xxx.XxxAction&quot;&gt;    &lt;property name=&quot;xxxService&quot; ref=&quot;xxxService&quot; /&gt;&lt;/bean&gt;</code></pre><p>   2.注册中心</p><pre><code>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。使用dubbo-2.3.3以上版本，建议使用zookeeper注册中心。Zookeeper是Apacahe Hadoop的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高，可用于生产环境，并推荐使用Zookeeper的安装：第一步：安装jdk第二步：解压缩zookeeper压缩包第三步：将conf文件夹下zoo_sample.cfg复制一份，改名为zoo.cfg第四步：修改配置dataDir属性，指定一个真实目录第五步：启动zookeeper：bin/zkServer.sh start关闭zookeeper：bin/zkServer.sh stop查看zookeeper状态：bin/zkServer.sh status</code></pre><h3 id="4-框架整合"><a href="#4-框架整合" class="headerlink" title="4.框架整合"></a>4.框架整合</h3><h4 id="添加dubbo的依赖"><a href="#添加dubbo的依赖" class="headerlink" title="添加dubbo的依赖"></a>添加dubbo的依赖</h4><pre><code>加入dubbo相关的jar包。服务层、表现层都添加。&lt;!-- dubbo相关 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;dubbo&lt;/artifactId&gt;        &lt;!-- 排除依赖 --&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring&lt;/artifactId&gt;            &lt;/exclusion&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.jboss.netty&lt;/groupId&gt;                &lt;artifactId&gt;netty&lt;/artifactId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;        &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;        &lt;artifactId&gt;zkclient&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><h4 id="整合思路"><a href="#整合思路" class="headerlink" title="整合思路"></a>整合思路</h4><pre><code>1、Dao层：mybatis整合spring，通过spring管理SqlSessionFactory、mapper代理对象。需要mybatis和spring的整合包。整合内容    对应工程Pojo   项目名称Mapper映射文件    项目名称Mapper接口    项目名称sqlmapConfig.xml    项目名称applicationContext-dao.xml    项目名称2、Service层：所有的service实现类都放到spring容器中管理。由spring创建数据库连接池，并有spring管理实务。发布dubbo服务整合内容    对应工程Service接口    项目名称service实现类    项目名称applicationContext-service.xml    项目名称applicationContext-trans.xml      项目名称（事务配置文件）3、表现层：Springmvc框架，由springmvc管理controller。引用dubbo服务整合内容    对应工程Springmvc.xml（扫描controller、引用dubbo服务）    项目名称Controller    项目名称</code></pre><h4 id="Dao整合"><a href="#Dao整合" class="headerlink" title="Dao整合"></a>Dao整合</h4><pre><code>创建SqlMapConfig.xml配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt;4.3.2.Spring整合mybatis创建applicationContext-dao.xml&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd&quot;&gt;    &lt;!-- 数据库连接池 --&gt;    &lt;!-- 加载配置文件 --&gt;    &lt;context:property-placeholder location=&quot;classpath:properties/*.properties&quot; /&gt;    &lt;!-- 数据库连接池 --&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;        destroy-method=&quot;close&quot;&gt;        &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;        &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt;        &lt;property name=&quot;minIdle&quot; value=&quot;5&quot; /&gt;    &lt;/bean&gt;    &lt;!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 --&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!-- 数据库连接池 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;        &lt;!-- 加载mybatis的全局配置文件 --&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt;    &lt;/bean&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.taotao.mapper&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;db.propertiesjdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/taotao?characterEncoding=utf-8jdbc.username=rootjdbc.password=root备注：Druid是目前最好的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss DataSource。Druid已经在阿里巴巴部署了超过600个应用，经过多年多生产环境大规模部署的严苛考验。</code></pre><h4 id="Service整合"><a href="#Service整合" class="headerlink" title="Service整合"></a>Service整合</h4><pre><code>管理Service&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd    http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.taotao.service&quot;&gt;&lt;/context:component-scan&gt;    &lt;!-- 使用dubbo发布服务 --&gt;    &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;    &lt;dubbo:application name=&quot;taotao-manager&quot; /&gt;    &lt;dubbo:registry protocol=&quot;zookeeper&quot;        address=&quot;192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183&quot; /&gt;    &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;    &lt;!-- 声明需要暴露的服务接口 --&gt;    &lt;dubbo:service interface=&quot;com.taotao.service.ItemService&quot; ref=&quot;itemServiceImpl&quot; /&gt;&lt;/beans&gt;</code></pre><h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><pre><code>创建applicationContext-trans.xml&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.2.xsd&quot;&gt;    &lt;!-- 事务管理器 --&gt;    &lt;bean id=&quot;transactionManager&quot;        class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;!-- 数据源 --&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;    &lt;/bean&gt;    &lt;!-- 通知 --&gt;    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;!-- 传播行为 --&gt;            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;create*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt;            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;            &lt;tx:method name=&quot;select*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;            &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!-- 切面 --&gt;    &lt;aop:config&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot;            pointcut=&quot;execution(* com.taotao.service.*.*(..))&quot; /&gt;    &lt;/aop:config&gt;&lt;/beans&gt;Web.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;    &lt;display-name&gt;taotao-manager&lt;/display-name&gt;    &lt;!-- 加载spring容器 --&gt;    &lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:spring/applicationContext*.xml&lt;/param-value&gt;    &lt;/context-param&gt;    &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;&lt;/web-app&gt;</code></pre><h4 id="表现层整合"><a href="#表现层整合" class="headerlink" title="表现层整合"></a>表现层整合</h4><pre><code>Springmvc.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;     xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.taotao.controller&quot; /&gt;    &lt;mvc:annotation-driven /&gt;    &lt;bean        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;    &lt;/bean&gt;    &lt;!-- 引用dubbo服务 --&gt;    &lt;dubbo:application name=&quot;taotao-manager-web&quot;/&gt;    &lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183&quot;/&gt;        &lt;dubbo:reference interface=&quot;com.taotao.service.ItemService&quot; id=&quot;itemService&quot; /&gt;&lt;/beans&gt;web.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;    id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;    &lt;display-name&gt;taotao-manager-web&lt;/display-name&gt;    &lt;welcome-file-list&gt;        &lt;welcome-file&gt;login.html&lt;/welcome-file&gt;    &lt;/welcome-file-list&gt;    &lt;!-- 解决post乱码 --&gt;    &lt;filter&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;utf-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;    &lt;!-- springmvc的前端控制器 --&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;taotao-manager&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!-- contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+&quot;-servlet.xml&quot; --&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;taotao-manager&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h2&gt;&lt;p&gt;web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的xml（标准通用标记语言下的一个子集）
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis命令</title>
    <link href="http://htuotuo.top/2018/02/24/redis%E5%91%BD%E4%BB%A4/"/>
    <id>http://htuotuo.top/2018/02/24/redis命令/</id>
    <published>2018-02-24T12:08:51.961Z</published>
    <updated>2018-02-24T12:32:13.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Redis-hash-常用命令"><a href="#1-Redis-hash-常用命令" class="headerlink" title="1.Redis hash 常用命令"></a>1.Redis hash 常用命令</h2><pre><code>1、HDEL key field1 [field2] 删除一个或多个哈希表字段`2、HEXISTS key field    查看哈希表 key 中，指定的字段是否存在。3、HGET key field    获取存储在哈希表中指定字段的值。`4、HGETALL key    获取在哈希表中指定 key 的所有字段和值5、HKEYS key    获取所有哈希表中的字段6、HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment 。7、HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。8、HLEN key    获取哈希表中字段的数量9、HMGET key field1 [field2]    获取所有给定字段的值10、HMSET key field1 value1 [field2 value2 ]    同时将多个 field-value (域-值)对设置到哈希表 key 中。11、HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。12、HSETNX key field value    只有在字段 field 不存在时，设置哈希表字段的值。</code></pre><h2 id="2-Redis-String-常用命令"><a href="#2-Redis-String-常用命令" class="headerlink" title="2.Redis String 常用命令"></a>2.Redis String 常用命令</h2><pre><code>1、SET key value  设置指定 key 的值2、GET key  获取指定 key 的值。3、GETRANGE key start end  返回 key 中字符串值的子字符4、GETSET key value  将给定 key 的值设为 value ，并返回 key 的旧值(old value)。5、GETBIT key offset 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。6、MGET key1 [key2..]  获取所有(一个或多个)给定 key 的值。7、SETBIT key offset value  对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。8、SETEX key seconds value  将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。9、SETNX key value  只有在 key 不存在时设置 key 的值。10、SETRANGE key offset value 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。11、STRLEN key  返回 key 所储存的字符串值的长度。12、MSET key value [key value ...]  同时设置一个或多个 key-value 对。13、MSETNX key value [key value ...]同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。14、PSETEX key milliseconds value这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。15、INCR key 将 key 中储存的数字值增一。16、INCRBY key increment 将 key 所储存的值加上给定的增量值（increment） 。17、INCRBYFLOAT key increment  将 key 所储存的值加上给定的浮点增量值（increment） 。18、DECR key 将 key 中储存的数字值减一。19、DECRBY key decrement key 所储存的值减去给定的减量值（decrement） 。20、APPEND key value如果 key 已经存在并且是一个字符串， APPEND 命令将 指定value 追加到改 key 原来的值（value）的末尾。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Redis-hash-常用命令&quot;&gt;&lt;a href=&quot;#1-Redis-hash-常用命令&quot; class=&quot;headerlink&quot; title=&quot;1.Redis hash 常用命令&quot;&gt;&lt;/a&gt;1.Redis hash 常用命令&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1、
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux常见命令</title>
    <link href="http://htuotuo.top/2018/02/24/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://htuotuo.top/2018/02/24/linux常见命令/</id>
    <published>2018-02-24T12:07:43.734Z</published>
    <updated>2018-03-14T04:55:26.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手动配置IP地址"><a href="#手动配置IP地址" class="headerlink" title="手动配置IP地址"></a>手动配置IP地址</h2><h3 id="自动获取IP地址"><a href="#自动获取IP地址" class="headerlink" title="自动获取IP地址"></a>自动获取IP地址</h3><pre><code>虚拟机使用桥接模式，相当于连接到物理机的网络里，物理机网络有DHCP服务器自动分配IP地址。#dhclient 自动获取ip地址命令#ifconfig 查询系统里网卡信息，ip地址、MAC地址分配到ip地址后，用物理机进行ping ip地址，检测是否ping通。</code></pre><h3 id="手动设置ip地址"><a href="#手动设置ip地址" class="headerlink" title="手动设置ip地址"></a>手动设置ip地址</h3><pre><code>如果虚拟机不能自动获取IP，只能手动配置，配置方法如下：输入命令#vi /etc/sysconfig/network-scripts/ifcfg-eth0编辑网卡的配置文件输入上述命令后回车，打开配置文件，使用方向键移动光标到最后一行，按字母键“O”，进入编辑模式，输入以下内容：IPADDR=192.168.25.10NETMASK=255.255.255.0GATEWAY=192.168.25.1另外光标移动到”ONBOOT=no”这一行，更改为ONBOOT=yes“BOOTPROTO=dhcp”，更改为BOOTPROTO=none完成后，按一下键盘左上角ESC键，输入:wq 在屏幕的左下方可以看到，输入回车保存配置文件。之后需要重启一下网络服务，命令为#service network restart网络重启后，eth0的ip就生效了，使用命令#ifconfigeth0 查看接下来检测配置的IP是否可以ping通，在物理机使用快捷键WINDOWS+R 打开运行框，输入命令cmd，输入ping 192.168.4.10 进行检测，ping通说明IP配置正确。备注：我所在的物理机网段为192.168.4.0 网段。大家做实验的时候根据自己的环境进行设定，保持虚拟机和物理机在同一网段即可。</code></pre><h3 id="使用NAT模式"><a href="#使用NAT模式" class="headerlink" title="使用NAT模式"></a>使用NAT模式</h3><pre><code>虚拟机网络连接使用NAT模式，物理机网络连接使用Vmnet8。虚拟机设置里面——网络适配器，网络连接选择NAT模式。虚拟机菜单栏—编辑—虚拟网络编辑器，选择Vmnet8 NAT模式，1．在最下面子网设置ip为192.168.20.0 子网掩码255.255.255.02．NAT设置里面网关IP为192.168.20.23．使用本地DHCP服务将IP地址分配给虚拟机不勾选设置完成后点击应用退出。CentOS 6.5 配置IP地址的三种方法物理机网络连接VMNet8 手动设置ip地址 192.168.20.1 子网掩码255.255.255.0网关和DNS地址为192.168.20.2（即虚拟机NAT的网关地址）编辑linux网卡eth0的配置文件#vi /etc/sysconfig/network-scripts/ifcfg-eth0输入上述命令后回车，打开配置文件，使用方向键移动光标到最后一行，按字母键“O”，进入编辑模式，输入以下内容：IPADDR=192.168.25.3NETMASK=255.255.255.0GATEWAY=192.168.25.2另外光标移动到”ONBOOT=no”这一行，更改为ONBOOT=yes“BOOTPROTO=dhcp”，更改为BOOTPROTO=none完成后，按一下键盘左上角ESC键，输入:wq 在屏幕的左下方可以看到，输入回车保存配置文件。设置DNS地址,运行命令#vi /etc/resolv.conf光标移动到空行，按“O”键，输入 nameserver 192.168.25.2 退出按ESC键，输入:wq 回车保存配置文件。重启网络服务#service network restart重启之后#ifconfig</code></pre><h2 id="unzip命令安装"><a href="#unzip命令安装" class="headerlink" title="unzip命令安装"></a>unzip命令安装</h2><pre><code>yum install zip unzip</code></pre><h2 id="解压缩和压缩"><a href="#解压缩和压缩" class="headerlink" title="解压缩和压缩"></a>解压缩和压缩</h2><pre><code>tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。常用参数：-c：创建一个新tar文件-v：显示运行过程的信息-f：指定文件名-z：调用gzip压缩命令进行压缩-t：查看压缩文件的内容-x：解开tar文件</code></pre><h2 id="jdk配置"><a href="#jdk配置" class="headerlink" title="jdk配置"></a>jdk配置</h2><pre><code>//打开/etc/profile文件# vim /etc/profile在文件末尾插入如下内容export JAVA_HOME=/home/soft/jdk1.8.0_111 export JRE_HOME=${JAVA_HOME}/jreexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH最后执行 source /etc/profile</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code>不询问递归删除（慎用）rm -rf  a  ?  不询问递归删除rm -rf *   ?   删除所有文件</code></pre><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><pre><code>管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。示例ls --help | more  分页查询帮助信息ps –ef | grep java  查询名称中包含java的进程ifconfig | morecat index.html | moreps –ef | grep aio</code></pre><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><pre><code>entOS 6.5关闭防火墙步骤临时关闭命令：  service iptables stop 永久关闭防火墙：chkconfig iptables off开启改为 on两个命令同时运行，运行完成后查看防火墙关闭状态 service iptables status</code></pre><h2 id="出现centos-yum报错Loaded-plugins-fastestmirror"><a href="#出现centos-yum报错Loaded-plugins-fastestmirror" class="headerlink" title="出现centos yum报错Loaded plugins: fastestmirror"></a>出现centos yum报错Loaded plugins: fastestmirror</h2><pre><code>vi /etc/yum/pluginconf.d/fastestmirror.conf enabled = 0vi /etc/yum.confplugins=0yum clean dbcache</code></pre><h2 id="在使用yum时如果出现：Cannot-find-a-valid-baseurl-for-repo-base-7-x86-64"><a href="#在使用yum时如果出现：Cannot-find-a-valid-baseurl-for-repo-base-7-x86-64" class="headerlink" title="在使用yum时如果出现：Cannot find a valid baseurl for repo: base/7/x86_64"></a>在使用yum时如果出现：Cannot find a valid baseurl for repo: base/7/x86_64</h2><pre><code>这种情况通常是，是因为没有配置DNS服务器。解决方法：用VI编辑resolv.conf文件命令vi /etc/resolv.conf添加：nameserver 114.114.114.114    国内的wq保存退出即可</code></pre><h2 id="授予权限-c-权限不够"><a href="#授予权限-c-权限不够" class="headerlink" title="授予权限  ///**/c: 权限不够"></a>授予权限  /<strong>/</strong>/**/c: 权限不够</h2><pre><code>chmod +x /**/**/**/c</code></pre><h2 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h2><pre><code>Redis是c语言开发的。安装redis需要c语言的编译环境。如果没有gcc需要在线安装。先查询系统中是否有gcc命令，如果出现下面提示，则表示你的系统中已经安装好了gcc命令    [root@admin ~]# gccgcc: 没有输入文件[root@admin ~]# makemake: *** 没有指明目标并且找不到 makefile。 停止。安装：在线，必须配置的ip地址与虚拟机网关在统一个网段![](https://i.imgur.com/2aWQZVJ.png)yum install gcc-c++安装步骤：第一步：redis的源码包上传到linux系统。第二步：解压缩redis。第三步：编译。make 第四步：安装。make install PREFIX=/usr/local/redis</code></pre><h3 id="redis的启动："><a href="#redis的启动：" class="headerlink" title="redis的启动："></a>redis的启动：</h3><pre><code>前端启动：[root@localhost bin]# ./redis-server 后台启动：把/root/redis-3.0.0/redis.conf复制到/usr/local/redis/bin目录下[root@localhost redis-3.0.0]# cp redis.conf /usr/local/redis/bin/修改配置文件：[root@localhost bin]# ./redis-server redis.conf查看redis进程：[root@localhost bin]# ps aux|grep redisroot      5190  0.1  0.3  33936  1712 ?        Ssl  18:23   0:00 ./redis-server *:6379    root      5196  0.0  0.1   4356   728 pts/0    S+   18:24   0:00 grep redis[root@localhost bin]# </code></pre><h2 id="在使用yum命令进行安装时可能出现："><a href="#在使用yum命令进行安装时可能出现：" class="headerlink" title="在使用yum命令进行安装时可能出现："></a>在使用yum命令进行安装时可能出现：</h2><pre><code>Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=6&amp;arch=x86_64&amp;repo=os error was14: PYCURL ERROR 6 - &quot;Couldn&apos;t resolve host &apos;mirrorlist.centos.org&apos;&quot;Error: Cannot find a valid baseurl for repo: base错误，如果出现此错误：解决：解决方法：编辑vi resolv.conf文件，添加：nameserver 8.8.8.8 </code></pre><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><pre><code>cp(选项)(参数)选项-a：此参数的效果和同时指定&quot;-dpR&quot;参数相同；-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；-f：强行复制文件或目录，不论目标文件或目录是否已存在；-i：覆盖既有文件之前先询问用户；-l：对源文件建立硬连接，而非复制文件；-p：保留源文件或目录的属性；-R/r：递归处理，将指定目录下的所有文件与子目录一并处理；-s：对源文件建立符号连接，而非复制文件；-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件；-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀；-b：覆盖已存在的文件目标前将目标文件备份；-v：详细显示命令执行的操作。</code></pre><h2 id="文本编辑命令"><a href="#文本编辑命令" class="headerlink" title="文本编辑命令"></a>文本编辑命令</h2><h3 id="进入vi-vim的命令"><a href="#进入vi-vim的命令" class="headerlink" title="进入vi/vim的命令"></a>进入vi/vim的命令</h3><pre><code>vi/vim filename :打开或新建文件，并将光标置于第一行首vi/vim +n filename ：打开文件，并将光标置于第n行首vi/vim + filename ：打开文件，并将光标置于最后一行首vi/vim +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处vi/vim -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filenamevi/vim filename….filename ：打开多个文件，依次进行编辑</code></pre><h3 id="屏幕翻滚类命令"><a href="#屏幕翻滚类命令" class="headerlink" title="屏幕翻滚类命令"></a>屏幕翻滚类命令</h3><pre><code>Ctrl+u：向文件首翻半屏Ctrl+d：向文件尾翻半屏Ctrl+f：向文件尾翻一屏Ctrl＋b；向文件首翻一屏nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。</code></pre><h3 id="插入文本类命令"><a href="#插入文本类命令" class="headerlink" title="插入文本类命令"></a>插入文本类命令</h3><pre><code>i ：在光标前I ：在当前行首a：光标后A：在当前行尾o：在当前行之下新开一行O：在当前行之上新开一行r：替换当前字符R：替换当前字符及其后的字符，直至按ESC键s：从当前光标位置处开始，以输入的文本替代指定数目的字符S：删除指定数目的行，并以所输入文本代替之ncw或nCW：修改指定数目的字nCC：修改指定数目的行</code></pre><h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><pre><code>ndw或ndW：删除光标处开始及其后的n-1个字do：删至行首d$：删至行尾ndd：删除当前行及其后n-1行x或X：删除一个字符，x删除光标后的，而X删除光标前的Ctrl+u：删除输入方式下所输入的文本</code></pre><h3 id="搜索及替换命令"><a href="#搜索及替换命令" class="headerlink" title="搜索及替换命令"></a>搜索及替换命令</h3><pre><code>/pattern：从光标开始处向文件尾搜索pattern?pattern：从光标开始处向文件首搜索patternn：在同一方向重复上一次搜索命令N：在反方向上重复上一次搜索命令：s/p1/p2/g：将当前行中所有p1均用p2替代：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代：g/p1/s//p2/g：将文件中所有p1均用p2替换</code></pre><h3 id="选项设置"><a href="#选项设置" class="headerlink" title="选项设置"></a>选项设置</h3><pre><code>all：列出所有选项设置情况term：设置终端类型ignorance：在搜索中忽略大小写list：显示制表位(Ctrl+I)和行尾标志（$)number：显示行号report：显示由面向行的命令修改过的数目terse：显示简短的警告信息warn：在转到别的文件时若没保存当前文件则显示NO write信息nomagic：允许在搜索模式中，使用前面不带“\”的特殊字符nowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始mesg：允许vi显示其他用户用write写到自己终端上的信息</code></pre><h3 id="末行模式命令"><a href="#末行模式命令" class="headerlink" title="末行模式命令"></a>末行模式命令</h3><pre><code>：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下：n1,n2 d ：将n1行到n2行之间的内容删除：w ：保存当前文件：e filename：打开文件filename进行编辑：x：保存当前文件并退出：q：退出vi：q!：不保存文件并退出vi：!command：执行shell命令command：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入：r!command：将命令command的输出结果放到当前行</code></pre><h2 id="linux查找日志技巧"><a href="#linux查找日志技巧" class="headerlink" title="linux查找日志技巧"></a>linux查找日志技巧</h2><pre><code>tail  -n  10  test.log   查询日志尾部最后10行的日志;tail -n +10 test.log    查询10行之后的所有日志;head -n 10  test.log   查询日志文件中的头10行日志;head -n -10  test.log   查询日志文件除了最后10行的其他所有日志;场景1: 按行号查看---过滤出关键字附近的日志因为通常时候我们用grep拿到的日志很少,我们需要查看附近的日志.我是这样做的,首先: cat -n test.log |grep &quot;地形&quot;  得到关键日志的行号&lt;3&gt;得到&quot;地形&quot;关键字所在的行号是102行. 此时如果我想查看这个关键字前10行和后10行的日志:cat -n test.log |tail -n +92|head -n 20tail -n +92表示查询92行之后的日志head -n 20 则表示在前面的查询结果里再查前20条记录场景2:那么按日期怎么查呢?  通常我们非常需要查找指定时间端的日志sed -n &apos;/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p&apos;  test.log特别说明:上面的两个日期必须是日志中打印出来的日志,否则无效.关于日期打印,可以先 grep &apos;2014-12-17 16:17:20&apos; test.log 来确定日志中是否有该时间点,以确保第4步可以拿到日志这个根据时间段查询日志是非常有用的命令.6如果我们查找的日志很多,打印在屏幕上不方便查看, 有两个方法:(1)使用more和less命令, 如: cat -n test.log |grep &quot;地形&quot; |more     这样就分页打印了,通过点击空格键翻页(2)使用 &gt;xxx.txt 将其保存到文件中,到时可以拉下这个文件分析.如:cat -n test.log |grep &quot;地形&quot;  &gt;xxx.txt</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;手动配置IP地址&quot;&gt;&lt;a href=&quot;#手动配置IP地址&quot; class=&quot;headerlink&quot; title=&quot;手动配置IP地址&quot;&gt;&lt;/a&gt;手动配置IP地址&lt;/h2&gt;&lt;h3 id=&quot;自动获取IP地址&quot;&gt;&lt;a href=&quot;#自动获取IP地址&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Excel解析和生成</title>
    <link href="http://htuotuo.top/2018/02/24/Excel%E8%A7%A3%E6%9E%90%E5%92%8C%E7%94%9F%E6%88%90/"/>
    <id>http://htuotuo.top/2018/02/24/Excel解析和生成/</id>
    <published>2018-02-24T12:06:01.987Z</published>
    <updated>2018-02-24T12:32:48.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-导入maven坐标"><a href="#1-导入maven坐标" class="headerlink" title="1.导入maven坐标"></a>1.导入maven坐标</h2><pre><code>基于 maven 坐标导入 POI 支持poi… jar 解析 HSSFpoi ooxml .. jar 解析 XSSF （以来 POI 包 ）</code></pre><h2 id="解析-Excel-逻辑"><a href="#解析-Excel-逻辑" class="headerlink" title="解析 Excel 逻辑"></a>解析 Excel 逻辑</h2><pre><code>工作薄 --- sheet --- row --- cell基于struts2进行文件上传的并解析// 接收上传文件private File file;public void setFile(File file) {    this.file = file;}// 批量区域数据导入@Action(value = &quot;area_batchImport&quot;)public String batchImport() throws IOException {    //创建区域集合    List&lt;Area&gt; areas = new ArrayList&lt;Area&gt;();    // 编写解析代码逻辑    // 基于.xls 格式解析 HSSF，也可以直接使用父类Workbook,可以解析xls和xlsx    // 1、 加载Excel文件对象    HSSFWorkbook hssfWorkbook = new HSSFWorkbook(new FileInputStream(file));    // 2、 读取一个sheet    HSSFSheet sheet=hssfWorkbook.getSheetAt(0);    // 3、 读取sheet中每一行    for (Row row : sheet) {        // 一行数据 对应 一个区域对象        //根据自己导入的数据表格格式进行解析，通常第一行为表头直接跳过        if (row.getRowNum() == 0) {            // 第一行 跳过            continue;        }        // 跳过空行        if (row.getCell(0) == null                || StringUtils.isBlank(row.getCell(0).getStringCellValue())) {            continue;        }        Area area = new Area();        area.setId(row.getCell(0).getStringCellValue());        area.setProvince(row.getCell(1).getStringCellValue());        area.setCity(row.getCell(2).getStringCellValue());        area.setDistrict(row.getCell(3).getStringCellValue());        area.setPostcode(row.getCell(4).getStringCellValue());        // 基于pinyin4j生成城市编码和简码,导入pingyin4J的坐标        String province = area.getProvince();        String city = area.getCity();        String district = area.getDistrict();        //去除省市区后缀        province = province.substring(0, province.length() - 1);        city = city.substring(0, city.length() - 1);        district = district.substring(0, district.length() - 1);        // 简码        String[] headArray = PinYin4jUtils.getHeadByString(province + city                + district);        StringBuffer buffer = new StringBuffer();        for (String headStr : headArray) {            buffer.append(headStr);        }        String shortcode = buffer.toString();        area.setShortcode(shortcode);        // 城市编码        String citycode = PinYin4jUtils.hanziToPinyin(city, &quot;&quot;);        area.setCitycode(citycode);        areas.add(area);    }    // 调用业务层    areaService.saveBatch(areas);    return NONE;}</code></pre><h2 id="生成-Excel-逻辑"><a href="#生成-Excel-逻辑" class="headerlink" title="生成 Excel 逻辑"></a>生成 Excel 逻辑</h2><pre><code>编写 ReportAction 添加 exportXls 方法POI 生成 Excel 步骤写 Excel 过程一样，新建 Excel 文档 -- 新建 Sheet -- 新建 Row --新建 Cell 单元格 -- 写单元格数据POI 生成 HSSF （xls）和 XSSF （xlsx）// 导出运单 报表     @Action(&quot;report_exportXls&quot;)    public String exportXls() throws IOException {        // 查询出 满足当前条件 结果数据        List&lt;WayBill&gt; wayBills = wayBillService.findWayBills(model);        // 生成Excel文件        HSSFWorkbook hssfWorkbook = new HSSFWorkbook();        HSSFSheet sheet = hssfWorkbook.createSheet(&quot;运单数据&quot;);        // 表头        HSSFRow headRow = sheet.createRow(0);        headRow.createCell(0).setCellValue(&quot;运单号&quot;);        headRow.createCell(1).setCellValue(&quot;寄件人&quot;);        headRow.createCell(2).setCellValue(&quot;寄件人电话&quot;);        headRow.createCell(3).setCellValue(&quot;寄件人地址&quot;);        headRow.createCell(4).setCellValue(&quot;收件人&quot;);        headRow.createCell(5).setCellValue(&quot;收件人电话&quot;);        headRow.createCell(6).setCellValue(&quot;收件人地址&quot;);        // 表格数据        for (WayBill wayBill : wayBills) {            HSSFRow dataRow = sheet.createRow(sheet.getLastRowNum() + 1);            dataRow.createCell(0).setCellValue(wayBill.getWayBillNum());            dataRow.createCell(1).setCellValue(wayBill.getSendName());            dataRow.createCell(2).setCellValue(wayBill.getSendMobile());            dataRow.createCell(3).setCellValue(wayBill.getSendAddress());            dataRow.createCell(4).setCellValue(wayBill.getRecName());            dataRow.createCell(5).setCellValue(wayBill.getRecMobile());            dataRow.createCell(6).setCellValue(wayBill.getRecAddress());        }        // 下载导出        // 设置头信息        ServletActionContext.getResponse().setContentType(                &quot;application/vnd.ms-excel&quot;);        String filename = &quot;运单数据.xls&quot;;        //设置浏览器编码        String agent = ServletActionContext.getRequest()                .getHeader(&quot;user-agent&quot;);        filename = FileUtils.encodeDownloadFilename(filename, agent);        //设置文件头以下载形式打开        ServletActionContext.getResponse().setHeader(&quot;Content-Disposition&quot;,                &quot;attachment;filename=&quot; + filename);        ServletOutputStream outputStream = ServletActionContext.getResponse()                .getOutputStream();        hssfWorkbook.write(outputStream);        // 关闭        hssfWorkbook.close();        return NONE;    }</code></pre><h2 id="生成pdf文件"><a href="#生成pdf文件" class="headerlink" title="生成pdf文件"></a>生成pdf文件</h2><h3 id="使用java原生代码生成pdf文件"><a href="#使用java原生代码生成pdf文件" class="headerlink" title="使用java原生代码生成pdf文件"></a>使用java原生代码生成pdf文件</h3><pre><code>@Action(&quot;report_exportPdf&quot;)public String exportPdf() throws IOException, DocumentException {    // 查询出 满足当前条件 结果数据    List&lt;WayBill&gt; wayBills = wayBillService.findWayBills(model);    // 下载导出    // 设置头信息    ServletActionContext.getResponse().setContentType(&quot;application/pdf&quot;);    String filename = &quot;运单数据.pdf&quot;;    String agent = ServletActionContext.getRequest()            .getHeader(&quot;user-agent&quot;);    filename = FileUtils.encodeDownloadFilename(filename, agent);    ServletActionContext.getResponse().setHeader(&quot;Content-Disposition&quot;,            &quot;attachment;filename=&quot; + filename);    // 生成PDF文件    Document document = new Document();    PdfWriter.getInstance(document, ServletActionContext.getResponse()            .getOutputStream());    document.open();    // 写PDF数据    // 向document 生成pdf表格    Table table = new Table(7);    table.setWidth(80); // 宽度    table.setBorder(1); // 边框    table.getDefaultCell().setHorizontalAlignment(Element.ALIGN_CENTER); // 水平对齐方式    table.getDefaultCell().setVerticalAlignment(Element.ALIGN_TOP); // 垂直对齐方式    // 设置表格字体    BaseFont cn = BaseFont.createFont(&quot;STSongStd-Light&quot;, &quot;UniGB-UCS2-H&quot;,            false);    Font font = new Font(cn, 10, Font.NORMAL, Color.BLUE);    // 写表头    table.addCell(buildCell(&quot;运单号&quot;, font));    table.addCell(buildCell(&quot;寄件人&quot;, font));    table.addCell(buildCell(&quot;寄件人电话&quot;, font));    table.addCell(buildCell(&quot;寄件人地址&quot;, font));    table.addCell(buildCell(&quot;收件人&quot;, font));    table.addCell(buildCell(&quot;收件人电话&quot;, font));    table.addCell(buildCell(&quot;收件人地址&quot;, font));    // 写数据    for (WayBill wayBill : wayBills) {        table.addCell(buildCell(wayBill.getWayBillNum(), font));        table.addCell(buildCell(wayBill.getSendName(), font));        table.addCell(buildCell(wayBill.getSendMobile(), font));        table.addCell(buildCell(wayBill.getSendAddress(), font));        table.addCell(buildCell(wayBill.getRecName(), font));        table.addCell(buildCell(wayBill.getRecMobile(), font));        table.addCell(buildCell(wayBill.getRecAddress(), font));    }    // 将表格加入文档    document.add(table);    document.close();    return NONE;}private Cell buildCell(String content, Font font)        throws BadElementException {    Phrase phrase = new Phrase(content, font);    return new Cell(phrase);}</code></pre><h3 id="使用jasperReport技术生成pdf文件"><a href="#使用jasperReport技术生成pdf文件" class="headerlink" title="使用jasperReport技术生成pdf文件"></a>使用jasperReport技术生成pdf文件</h3><pre><code>    @Action(&quot;report_exportJasperPdf&quot;)    public String exportJasperPdf() throws IOException, DocumentException,            JRException, SQLException {        // 查询出 满足当前条件 结果数据        List&lt;WayBill&gt; wayBills = wayBillService.findWayBills(model);        // 下载导出        // 设置头信息        ServletActionContext.getResponse().setContentType(&quot;application/pdf&quot;);        String filename = &quot;运单数据.pdf&quot;;        String agent = ServletActionContext.getRequest()                .getHeader(&quot;user-agent&quot;);        filename = FileUtils.encodeDownloadFilename(filename, agent);        ServletActionContext.getResponse().setHeader(&quot;Content-Disposition&quot;,                &quot;attachment;filename=&quot; + filename);        // 根据 jasperReport模板 生成pdf,借助ireport工具生成模板        // 读取模板文件        String jrxml = ServletActionContext.getServletContext().getRealPath(                &quot;/WEB-INF/jasper/waybill.jrxml&quot;);        JasperReport report = JasperCompileManager.compileReport(jrxml);        // 设置模板数据，根据模板样式来设置参数        // Parameter变量        Map&lt;String, Object&gt; paramerters = new HashMap&lt;String, Object&gt;();        paramerters.put(&quot;company&quot;, &quot;传智播客&quot;);        // Field变量        JasperPrint jasperPrint = JasperFillManager.fillReport(report,                paramerters, new JRBeanCollectionDataSource(wayBills));        // 生成PDF客户端        JRPdfExporter exporter = new JRPdfExporter();        exporter.setParameter(JRExporterParameter.JASPER_PRINT, jasperPrint);        exporter.setParameter(JRExporterParameter.OUTPUT_STREAM,                ServletActionContext.getResponse().getOutputStream());        exporter.exportReport();// 导出        ServletActionContext.getResponse().getOutputStream().close();        return NONE;    }}</code></pre><h2 id="附加ireport工具使用"><a href="#附加ireport工具使用" class="headerlink" title="附加ireport工具使用"></a>附加ireport工具使用</h2><h2 id="IReport-报表模板简介和设置中文生成"><a href="#IReport-报表模板简介和设置中文生成" class="headerlink" title="IReport 报表模板简介和设置中文生成"></a>IReport 报表模板简介和设置中文生成</h2><h3 id="1、新建-JasperReport-模板文件-jrxml"><a href="#1、新建-JasperReport-模板文件-jrxml" class="headerlink" title="1、新建 JasperReport 模板文件 .jrxml"></a>1、新建 JasperReport 模板文件 .jrxml</h3><h3 id="2、设置默认语言"><a href="#2、设置默认语言" class="headerlink" title="2、设置默认语言"></a>2、设置默认语言</h3><pre><code>对输入中文内容 设置组件属性</code></pre><p><img src="https://i.imgur.com/H4eh44k.png" alt=""></p><pre><code>在 IReport 引入 ITextAsian.jar 字库在工具选项中    </code></pre><p><img src="https://i.imgur.com/hmOetdY.png" alt=""></p><h3 id="3、-了解报表模板结构"><a href="#3、-了解报表模板结构" class="headerlink" title="3、 了解报表模板结构"></a>3、 了解报表模板结构</h3><pre><code>Title: 报表标题PageHeader: 页眉ColumnHeader: 表格列标题Detail： 表格数据内容ColumnFooter： 表格页脚PageFooter： 页脚Summary: 摘要</code></pre><h3 id="4、-常用报表组件"><a href="#4、-常用报表组件" class="headerlink" title="4、 常用报表组件"></a>4、 常用报表组件</h3><p><img src="https://i.imgur.com/lZrtNKt.png" alt=""></p><pre><code>设置预览格式为 PDF</code></pre><h2 id="4-3．-IReport-配置数据库连接，基于数据表生成报表"><a href="#4-3．-IReport-配置数据库连接，基于数据表生成报表" class="headerlink" title="4.3． IReport 配置数据库连接，基于数据表生成报表"></a>4.3． IReport 配置数据库连接，基于数据表生成报表</h2><pre><code>1、 点击按钮配置数据库连接新建 JDBC 连接</code></pre><p><img src="https://i.imgur.com/VvJwgM5.png" alt=""><br>    2、 在 ireport 添加 oracle 的 jdbc 驱动<br><img src="https://i.imgur.com/qqPYAOd.png" alt=""><br><img src="https://i.imgur.com/uIXnf1h.png" alt=""><br>    3、 通过 ReportQuery 查询数据库<br><img src="https://i.imgur.com/vzo4vXn.png" alt=""><br><img src="https://i.imgur.com/TmPcw2t.png" alt=""><br>    4、 设计报表<br><img src="https://i.imgur.com/Qlhe23r.png" alt=""></p><h2 id="4-4．-JasperResport-根据模板文件-生成报表"><a href="#4-4．-JasperResport-根据模板文件-生成报表" class="headerlink" title="4.4． JasperResport 根据模板文件 生成报表"></a>4.4． JasperResport 根据模板文件 生成报表</h2><pre><code>1、 设置 ireport 字段 自动换行</code></pre><p><img src="https://i.imgur.com/HsGtGsM.png" alt=""></p><pre><code>2、 将 waybill.jrxml 复制 bos_management3、 在 waybill_manage.html 页面添加按钮4、 在 common-parent 导入 jasperReport 开发包5、 在 ReportAction 添加 exportJasperPdf 方法</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-导入maven坐标&quot;&gt;&lt;a href=&quot;#1-导入maven坐标&quot; class=&quot;headerlink&quot; title=&quot;1.导入maven坐标&quot;&gt;&lt;/a&gt;1.导入maven坐标&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;基于 maven 坐标导入 POI 支持
poi… 
      
    
    </summary>
    
    
  </entry>
  
</feed>
